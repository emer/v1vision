// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

import (
	"github.com/emer/v1vision/kwta"
)

// alias so it works locally too.
type KWTA = kwta.KWTA

// NewNeighInhib4 adds a [NeighInhib4] operation, from in value -> out value.
// fn is number of filters (innermost values dimension). must be 4!
// gi is inhibition strength.
// Output value has additional inhibition for active neighbors of same filter index.
// returns out index.
func (vv *V1Vision) NewNeighInhib4(in, fn int, gi float32, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for NeighInhib4!")
	}
	op := vv.NewOp()
	op.Op = NeighInhib4
	out := vv.NewNeighInhibOutput(fn, geom)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.FloatArg1 = gi
	op.Geom = *geom
	return out
}

// NewNeighInhibOutput add Values for a [NeighInhib] operation.
// fn is number of filters (innermost values dimension). returns out index.
func (vv *V1Vision) NewNeighInhibOutput(fn int, geom *Geom) int {
	return vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
}


// NewKWTA adds a [KWTAInhib] operation, on Values data.
// in = raw initial inputs, inExtGi = extra Gi inhibition
// typically from [NeighInhib4] -- if 0 then not used.
// fn is number of filters (innermost values dimension).
// geom.Out is the size of the outer Y,X dimensions, and 
// FilterSz is the inner Y,X dimensions.
// Allocates a Inhibsto hold the inhibition compute values,
// including an additional Y row for the layer-level values at the end.
func (vv *V1Vision) NewKWTA(in, inExtGi, fn, kwtaIdx int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = KWTAInhib
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	inh := vv.NewInhibs(int(geom.Out.Y+1), int(geom.Out.X+1))
	op.RunN = uint32(geom.Out.Y * geom.Out.X)
	op.InValue = int32(in)
	op.InValue2 = int32(inExtGi)
	op.OutValue = int32(out)
	op.Inhibs = int32(inh)
	op.FilterN = int32(fn)
	op.KWTA = int32(kwtaIdx)
	op.Geom = *geom
	return out
}

//gosl:start

// NeighInhib4 is kernel.
func (op *Op) NeighInhib4(i uint32) {
	ang := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	gi := float32(0)

	var ox, oy int32
	NeighInhibOffsets(ang, &ox, &oy)
	
	npX := xo + ox
	npY := yo + oy
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, ang]
		gi = max(gi, v)
	}
	npX = xo - ox
	npY = yo - oy
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, ang]
		gi = max(gi, v)
	}
	Values[op.OutValue, yo, xo, pi, ang] = op.FloatArg1 * gi
}

// KWTAInitPool is the kernel to initialize KWTA process, on Values data.
// i = op.Geom.Out.Y * X. 2 x FilterN is inner 2 dims. Operates on Inhibs.
// InValue = raw initial activations (ge)
// OutValue = acts (output result)
func KWTAInitPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	pn := 2 * op.FilterN
	
	geAvg := float32(0)
	geMax := float32(0)
	for py := range 2 { // for 4D, FilterSz.Y
		for px := range op.FilterN {
			ge := Values[op.InValue, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
		}
	}
	
	for i := range InhibVarsN {
		Inhibs[op.Inhibs, yo, xo, int(i)] = 0.0
	}
	Inhibs[op.Inhibs, yo, xo, GeAvg] = geAvg / float32(pn)
	Inhibs[op.Inhibs, yo, xo, GeMax] = geMax
}

// KWTAInitLayer is the kernel to initialize KWTA process for layer 
// on Values data. Run = 1 only. Operates on Inhibs. 
func KWTAInitLayer(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	lyi := op.Geom.Out.Y
	for i := range InhibVarsN {
		Inhibs[op.Inhibs, lyi, 0, int(i)] = 0.0
	}
}
	
// KWTAIterLayerX is the kernel to iterate KWTA process at layer, 
// first pass, operating on X dimension.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Inhibs updated from pool-level.
// Call this first then IterPool
func KWTAIterLayerX(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	yo := int32(i)
	if yo >= szY {
		return
	}
	ln := float32(szY)

	geAvg := float32(0)
	geMax := float32(0)
	actAvg := float32(0)
	actMax := float32(0)
	for xo := range szX {
		gavg := Inhibs[op.Inhibs, yo, xo, GeAvg]
		gmx := Inhibs[op.Inhibs, yo, xo, GeMax]
		aavg := Inhibs[op.Inhibs, yo, xo, ActAvg]
		amx := Inhibs[op.Inhibs, yo, xo, ActMax]
		geAvg += gavg
		geMax = max(geMax, gmx)
		actAvg += aavg
		actMax = max(actMax, amx)
	}
	geAvg /= ln
	actAvg /= ln
	Inhibs[op.Inhibs, yo, szX, GeAvg] = geAvg
	Inhibs[op.Inhibs, yo, szX, GeMax] = geMax
	Inhibs[op.Inhibs, yo, szX, ActAvg] = actAvg
	Inhibs[op.Inhibs, yo, szX, ActMax] = actMax
}

// KWTAIterLayerY is the kernel to iterate KWTA process at layer.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Inhibs updated from pool-level.
// Call this first then IterPool
func KWTAIterLayerY(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	ln := float32(szY)

	geAvg := float32(0)
	geMax := float32(0)
	actAvg := float32(0)
	actMax := float32(0)
	for yo := range szY {
		gavg := Inhibs[op.Inhibs, yo, szX, GeAvg]
		gmx := Inhibs[op.Inhibs, yo, szX, GeMax]
		aavg := Inhibs[op.Inhibs, yo, szX, ActAvg]
		amx := Inhibs[op.Inhibs, yo, szX, ActMax]
		geAvg += gavg
		geMax = max(geMax, gmx)
		actAvg += aavg
		actMax = max(actMax, amx)
	}
	geAvg /= ln
	actAvg /= ln
	Inhibs[op.Inhibs, szY, 0, GeAvg] = geAvg
	Inhibs[op.Inhibs, szY, 0, GeMax] = geMax
	Inhibs[op.Inhibs, szY, 0, ActAvg] = actAvg
	Inhibs[op.Inhibs, szY, 0, ActMax] = actMax

	kp := GetKWTAs(uint32(op.KWTA))
	fbi := Inhibs[op.Inhibs, szY, 0, FBi]
	ffi := kp.Layer.FFInhib(geAvg, geMax)
	newFBi := kp.Layer.FBInhib(actAvg)
	fbi = kp.Layer.FBUpdt(fbi, newFBi)
	if kp.Layer.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}
	
	Inhibs[op.Inhibs, szY, 0, FFi] = ffi
	Inhibs[op.Inhibs, szY, 0, FBi] = fbi
	
	gi := kp.Layer.Gi * (ffi + fbi)
	Inhibs[op.Inhibs, szY, 0, Gi] = gi
	Inhibs[op.Inhibs, szY, 0, GiOrig] = gi
}

// KWTAIterPool is the kernel to iterate KWTA process for Pools.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims. Operates on Inhibs.
// InValue = raw initial activations (ge)
// InValue2 = extra Gi values, if non-0
// OutValue = acts (output result)
func KWTAIterPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	yo := int32(i) / szX
	xo := int32(i) % szX

	layGi := Inhibs[op.Inhibs, szY, 0, Gi]
	kp := GetKWTAs(uint32(op.KWTA))
	
	pn := 2 * op.FilterN
	// pn := op.Geom.FilterSz.Y * op.Geom.FilterSz.X
	
	geAvg := Inhibs[op.Inhibs, yo, xo, GeAvg]
	geMax := Inhibs[op.Inhibs, yo, xo, GeMax]
	actAvg := Inhibs[op.Inhibs, yo, xo, ActAvg]
	fbi := Inhibs[op.Inhibs, yo, xo, FBi]
	ffi := kp.Pool.FFInhib(geAvg, geMax)
	newFBi := kp.Pool.FBInhib(actAvg)
	fbi = kp.Pool.FBUpdt(fbi, newFBi)
	if kp.Pool.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}
	
	Inhibs[op.Inhibs, yo, xo, FFi] = ffi
	Inhibs[op.Inhibs, yo, xo, FBi] = fbi
	
	gi := kp.Pool.Gi * (ffi + fbi)
	Inhibs[op.Inhibs, yo, xo, Gi] = gi
	Inhibs[op.Inhibs, yo, xo, GiOrig] = gi

	giPool := max(layGi, gi)
	
	actAvg = 0.0
	actMax := float32(0.0)
	for py := range 2 { // op.Geom.FilterSz.Y {
		for px := range op.FilterN {
			pgi := giPool
			if op.InValue2 > 0 {
				eIn := Values[op.InValue2, yo, xo, py, px]
				eGi := kp.Pool.Gi * kp.Pool.FFInhib(eIn, eIn)
				pgi = max(pgi, eGi)
			}
			geThr := kp.GeThrFromG(pgi)
			ge := Values[op.InValue, yo, xo, py, px]
			act := Values[op.OutValue, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
			delAct := float32(0)
			nwAct := kp.ActFromG(geThr, ge, act, &delAct)
			// maxDelAct = max(maxDelAct, math32.Abs(delAct)) // todo
			Values[op.OutValue, yo, xo, py, px] = nwAct
			actAvg += nwAct
			actMax = max(actMax, nwAct)
		}
	}
	Inhibs[op.Inhibs, yo, xo, ActAvg] = actAvg / float32(pn)
	Inhibs[op.Inhibs, yo, xo, ActMax] = actMax
}

// Neigh4X = []int{0, -1, 1, -1}
// Neigh4Y = []int{1, 1, 0, -1}

// ortho neighbor coordinates for 4 angles, also uses negated version
//  .
// --- = (0,1) (X,Y)
// . /
//  /  = (-1,1)
// | .  = (1,0)
//  \
// . \  = (-1,-1)
func NeighInhibOffsets(ang int32, ox, oy *int32) {
	switch ang {
	case 1, 3:
		*ox = -1
	case 2:
		*ox = 1
	default:
		*ox = 0
	}
	switch ang {
	case 0, 1:
		*oy = 1
	case 3:
		*oy = -1
	default:
		*oy = 0
	}
}

//gosl:end

