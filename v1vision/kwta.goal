// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewNeighInhib adds a [NeighInhib] operation, from in value -> out value.
// fn is number of filters (innermost values dimension). gi is inhibition strength.
// Out value has additional inhibition for active neighbors of same filter index.
// returns out index.
func (vv *V1Vision) NewNeighInhib(in, fn int, gi float32, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for NeighInhib!")
	}
	op := vv.NewOp()
	op.Op = ConvolveImage
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.FloatArg1 = gi
	op.Geom = *geom
	return out
}

// NewKWTA adds a [KWTA] operation, from in value -> out values.
// fn is number of filters (innermost values dimension).
// geom.In is the size of the input values, and geom.Out is the output,
// where geom is: Out = (In / Spacing), and FilterSz <= Spacing.
// (e.g., use geom.SetFilter)
func (vv *V1Vision) NewKWTA(in, fn int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = ConvolveImage
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

//gosl:start

// NeighInhib is kernel.
func (op *Op) NeighInhib(i uint32) {
	fi := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	gi := float32(0)

	// ortho neighbor coordinates for 4 angles, also uses negated version
	//  .
	// --- = (0,1) (X,Y)
	// . /
	//  /  = (-1,1)
	// | .  = (1,0)
	//  \
	// . \  = (-1,-1)

	nx := int32(0)
	switch fi { // angle
	case 1, 3:
		nx = -1
	case 2:
		nx = 1
	default:
	}
	ny := int32(0)
	switch fi {
	case 0, 1:
		ny = 1
	case 3:
		ny = -1
	default:
	}
	npX := xo + nx
	npY := yo + ny
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, fi]
		gi = max(gi, v)
	}
	npX = xo - nx
	npY = yo - ny
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, fi]
		gi = max(gi, v)
	}
	Values[op.OutValue, yo, xo, pi, fi] = gi
}

// KWTAInit is the kernel to initialize KWTA process.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Values4D:
// InValue = raw initial activations (ge)
// InValue+1 = extra Gi values
// OutValue = inhibs (inner dims 1, InhibValuesN)
// OutValue+1 = acts (output result)
func KWTAInit(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	pn := op.Geom.FilterSz.Y * op.Geom.FilterSz.X
	
	geAvg := float32(0)
	geMax := float32(0)
	for py := range op.Geom.FilterSz.Y {
		for px := range op.Geom.FilterSz.X {
			ge := Values4D[op.InValue, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
		}
	}
	
	for i := range InhibVarsN {
		Values4D[op.OutValue, yo, xo, 0, int(i)] = 0.0
	}
	Values4D[op.OutValue, yo, xo, 0, GeAvg] = geAvg / float32(pn)
	Values4D[op.OutValue, yo, xo, 0, GeMax] = geMax
}

// KWTAIter is the kernel to iterate KWTA process.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Values4D:
// InValue = raw initial activations (ge)
// InValue+1 = extra Gi values
// OutValue = inhibs (inner dims 1, InhibValuesN)
// OutValue+1 = acts (output result)
// InScalar = layerGi
func KWTAIter(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	layGi := Scalars.Value1D(int(op.InScalar))
	kp := GetKWTAs(uint32(op.KWTA))
	
	pn := op.Geom.FilterSz.Y * op.Geom.FilterSz.X
	
	geAvg := Values4D[op.OutValue, yo, xo, 0, GeAvg]
	geMax := Values4D[op.OutValue, yo, xo, 0, GeMax]
	actAvg := Values4D[op.OutValue, yo, xo, 0, ActAvg]
	fbi := Values4D[op.OutValue, yo, xo, 0, FBi]
	ffi := kp.PoolFFFB.FFInhib(geAvg, geMax)
	newFBi := kp.PoolFFFB.FBInhib(actAvg)
	fbi = kp.PoolFFFB.FBUpdt(fbi, newFBi)
	
	Values4D[op.OutValue, yo, xo, 0, FFi] = ffi
	Values4D[op.OutValue, yo, xo, 0, FBi] = fbi
	
	gi := kp.PoolFFFB.Gi * (ffi + fbi)
	Values4D[op.OutValue, yo, xo, 0, Gi] = gi
	Values4D[op.OutValue, yo, xo, 0, GiOrig] = gi

	giPool := max(layGi, gi)
	
	actAvg = 0.0
	actMax := float32(0.0)
	for py := range op.Geom.FilterSz.Y {
		for px := range op.Geom.FilterSz.X {
			pgi := giPool
			eIn := Values4D[op.InValue+1, yo, xo, py, px]
			eGi := kp.PoolFFFB.Gi * kp.PoolFFFB.FFInhib(eIn, eIn)
			pgi = max(pgi, eGi)
			geThr := kp.GeThrFromG(pgi)
			ge := Values4D[op.InValue, yo, xo, py, px]
			act := Values4D[op.OutValue+1, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
			delAct := float32(0)
			nwAct := kp.ActFromG(geThr, ge, act, &delAct)
			// maxDelAct = max(maxDelAct, math32.Abs(delAct)) // todo
			Values4D[op.OutValue+1, yo, xo, py, px] = act
			actAvg += nwAct
			actMax = max(actMax, nwAct)
		}
	}
	Values4D[op.OutValue, yo, xo, 0, ActAvg] = actAvg / float32(pn)
	Values4D[op.OutValue, yo, xo, 0, ActMax] = actMax
}

//gosl:end

