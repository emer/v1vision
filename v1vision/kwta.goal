// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

import (
	"github.com/emer/v1vision/kwta"
)

// alias so it works locally too.
type KWTA = kwta.KWTA

// NewNeighInhib adds a [NeighInhib] operation, from in value -> out value.
// fn is number of filters (innermost values dimension). gi is inhibition strength.
// Out value has additional inhibition for active neighbors of same filter index.
// returns out index.
func (vv *V1Vision) NewNeighInhib(in, fn int, gi float32, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for NeighInhib!")
	}
	op := vv.NewOp()
	op.Op = NeighInhib
	out := vv.NewNeighInhibOutput(fn, geom)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.FloatArg1 = gi
	op.Geom = *geom
	return out
}

// NewNeighInhibOutput add Values for a [NeighInhib] operation.
// fn is number of filters (innermost values dimension). returns out index.
func (vv *V1Vision) NewNeighInhibOutput(fn int, geom *Geom) int {
	return vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
}


// NewKWTA adds a [KWTAInhib] operation, on Values data.
// fn is number of filters (innermost values dimension).
// geom.Out is the size of the outer Y,X dimensions, and 
// FilterSz is the inner Y,X dimensions.
// Allocates a Values4D to hold the inhibition compute values,
// including an additional Y row for the layer-level values at the end.
func (vv *V1Vision) NewKWTA(in, fn int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = KWTAInhib
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	oinh := vv.NewValues4D(int(geom.Out.Y+1), int(geom.Out.X), 1, int(InhibVarsN))
	op.RunN = uint32(geom.Out.Y * geom.Out.X)
	op.InValue = int32(in) // note: must have neigh inhib just after this!
	op.OutValue = int32(out)
	op.OutValue4D = int32(oinh)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

//gosl:start

// NeighInhib is kernel.
func (op *Op) NeighInhib(i uint32) {
	fi := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	gi := float32(0)

	// ortho neighbor coordinates for 4 angles, also uses negated version
	//  .
	// --- = (0,1) (X,Y)
	// . /
	//  /  = (-1,1)
	// | .  = (1,0)
	//  \
	// . \  = (-1,-1)

	nx := int32(0)
	switch fi { // angle
	case 1, 3:
		nx = -1
	case 2:
		nx = 1
	default:
	}
	ny := int32(0)
	switch fi {
	case 0, 1:
		ny = 1
	case 3:
		ny = -1
	default:
	}
	npX := xo + nx
	npY := yo + ny
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, fi]
		gi = max(gi, v)
	}
	npX = xo - nx
	npY = yo - ny
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values[op.InValue, npY, npX, pi, fi]
		gi = max(gi, v)
	}
	Values[op.OutValue, yo, xo, pi, fi] = op.FloatArg1 * gi
}

// KWTAInitPool is the kernel to initialize KWTA process, on Values data.
// i = op.Geom.Out.Y * X. 2 x FilterN is inner 2 dims
// Operates on Values4D:
// InValue = raw initial activations (ge)
// InValue+1 = extra Gi values
// OutValue4D = inhibs (inner dims 1, InhibValuesN)
// OutValue = acts (output result)
func KWTAInitPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	pn := 2 * op.FilterN
	
	geAvg := float32(0)
	geMax := float32(0)
	for py := range 2 { // for 4D, FilterSz.Y
		for px := range op.FilterN {
			ge := Values[op.InValue, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
		}
	}
	
	for i := range InhibVarsN {
		Values4D[op.OutValue4D, yo, xo, 0, int(i)] = 0.0
	}
	Values4D[op.OutValue4D, yo, xo, 0, GeAvg] = geAvg / float32(pn)
	Values4D[op.OutValue4D, yo, xo, 0, GeMax] = geMax
}

// KWTAInitLayer is the kernel to initialize KWTA process for layer 
// on Values data. Run = 1 only.
// OutValue4D = inhibs (inner dims 1, InhibValuesN)
func KWTAInitLayer(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	lyi := op.Geom.Out.Y
	for i := range InhibVarsN {
		Values4D[op.OutValue4D, lyi, 0, 0, int(i)] = 0.0
	}
}

// KWTAIterLayer is the kernel to iterate KWTA process at layer.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Values4D updated from pool-level:
// OutValue4D = inhibs (inner dims 1, InhibValuesN)
// Call this first then IterPool
func KWTAIterLayer(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	lyi := int(op.Geom.Out.Y)
	ln := float32(op.Geom.Out.Y * op.Geom.Out.X)
	kp := GetKWTAs(uint32(op.KWTA))

	geAvg := float32(0)
	geMax := float32(0)
	actAvg := float32(0)
	actMax := float32(0)
	for yo := range op.Geom.Out.Y {
		for xo := range op.Geom.Out.X {
			gavg := Values4D[op.OutValue4D, yo, xo, 0, GeAvg]
			gmx := Values4D[op.OutValue4D, yo, xo, 0, GeMax]
			aavg := Values4D[op.OutValue4D, yo, xo, 0, ActAvg]
			amx := Values4D[op.OutValue4D, yo, xo, 0, ActMax]
			geAvg += gavg
			geMax = max(geMax, gmx)
			actAvg += aavg
			actMax = max(actMax, amx)
		}
	}
	geAvg /= ln
	actAvg /= ln
	Values4D[op.OutValue4D, lyi, 0, 0, GeAvg] = geAvg
	Values4D[op.OutValue4D, lyi, 0, 0, GeMax] = geMax
	Values4D[op.OutValue4D, lyi, 0, 0, ActAvg] = actAvg
	Values4D[op.OutValue4D, lyi, 0, 0, ActMax] = actMax
	
	fbi := Values4D[op.OutValue4D, lyi, 0, 0, FBi]
	ffi := kp.Layer.FFInhib(geAvg, geMax)
	newFBi := kp.Layer.FBInhib(actAvg)
	fbi = kp.Layer.FBUpdt(fbi, newFBi)
	if kp.Layer.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}
	
	Values4D[op.OutValue4D, lyi, 0, 0, FFi] = ffi
	Values4D[op.OutValue4D, lyi, 0, 0, FBi] = fbi
	
	gi := kp.Layer.Gi * (ffi + fbi)
	Values4D[op.OutValue4D, lyi, 0, 0, Gi] = gi
	Values4D[op.OutValue4D, lyi, 0, 0, GiOrig] = gi
}

// KWTAIterPool is the kernel to iterate KWTA process for Pools.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Values4D:
// InValue = raw initial activations (ge)
// InValue+1 = extra Gi values
// OutValue4D = inhibs (inner dims 1, InhibValuesN)
// OutValue = acts (output result)
func KWTAIterPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	lyi := int(op.Geom.Out.Y)
	layGi := Values4D[op.OutValue4D, lyi, 0, 0, Gi]
	kp := GetKWTAs(uint32(op.KWTA))
	
	pn := 2 * op.FilterN
	// pn := op.Geom.FilterSz.Y * op.Geom.FilterSz.X
	
	geAvg := Values4D[op.OutValue4D, yo, xo, 0, GeAvg]
	geMax := Values4D[op.OutValue4D, yo, xo, 0, GeMax]
	actAvg := Values4D[op.OutValue4D, yo, xo, 0, ActAvg]
	fbi := Values4D[op.OutValue4D, yo, xo, 0, FBi]
	ffi := kp.Pool.FFInhib(geAvg, geMax)
	newFBi := kp.Pool.FBInhib(actAvg)
	fbi = kp.Pool.FBUpdt(fbi, newFBi)
	if kp.Pool.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}
	
	Values4D[op.OutValue4D, yo, xo, 0, FFi] = ffi
	Values4D[op.OutValue4D, yo, xo, 0, FBi] = fbi
	
	gi := kp.Pool.Gi * (ffi + fbi)
	Values4D[op.OutValue4D, yo, xo, 0, Gi] = gi
	Values4D[op.OutValue4D, yo, xo, 0, GiOrig] = gi

	giPool := max(layGi, gi)
	
	actAvg = 0.0
	actMax := float32(0.0)
	for py := range 2 { // op.Geom.FilterSz.Y {
		for px := range op.FilterN {
			pgi := giPool
			eIn := Values[op.InValue+1, yo, xo, py, px]
			eGi := kp.Pool.Gi * kp.Pool.FFInhib(eIn, eIn)
			pgi = max(pgi, eGi)
			geThr := kp.GeThrFromG(pgi)
			ge := Values[op.InValue, yo, xo, py, px]
			act := Values[op.OutValue, yo, xo, py, px]
			geAvg += ge
			geMax = max(geMax, ge)
			delAct := float32(0)
			nwAct := kp.ActFromG(geThr, ge, act, &delAct)
			// maxDelAct = max(maxDelAct, math32.Abs(delAct)) // todo
			Values[op.OutValue, yo, xo, py, px] = nwAct
			actAvg += nwAct
			actMax = max(actMax, nwAct)
		}
	}
	Values4D[op.OutValue4D, yo, xo, 0, ActAvg] = actAvg / float32(pn)
	Values4D[op.OutValue4D, yo, xo, 0, ActMax] = actMax
}

//gosl:end

