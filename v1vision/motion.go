// Code generated by "goal build"; DO NOT EDIT.
//line motion.goal:1
// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewMotionIntegrate adds a [MotionIntegrate] operation,
// operating on given values input index, with given number of filters.
// fastTau and slowTau are the tau time constants for integrating.
// Adds two new Values for output: Fast and Slow, index of Fast returned.
func (vv *V1Vision) NewMotionIntegrate(in, fn int, fastTau, slowTau float32, geom *Geom) int {
	fast := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn) // slow
	op := vv.NewOp()
	op.Op = MotionIntegrate
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(fast)
	op.FilterN = int32(fn)
	op.FloatArg1 = 1.0 / fastTau
	op.FloatArg2 = 1.0 / slowTau
	op.Geom = *geom
	return fast
}

// NewMotionStar adds a [MotionStar] operation,
// operating on given values input index = fast, +1 = slow,
// with given number of original input filters.
// Adds new Values for output, nf = orig nf * 4 (left, right, down, up),
// index returned.
func (vv *V1Vision) NewMotionStar(in, fn int, gain float32, geom *Geom) int {
	nfn := fn * 4
	oy := int(geom.Out.Y - 1)
	ox := int(geom.Out.X - 1)
	out := vv.NewValues(oy, ox, nfn)
	op := vv.NewOp()
	op.Op = MotionStar
	op.RunN = uint32(oy * ox * int(fn*2) * 2) // lr,du dir for run
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn * 2)
	op.FloatArg1 = gain
	op.Geom = *geom
	return out
}

// NewMotionFullField adds a [MotionFullField] operation,
// operating on given values input index = star output.
// with given number of original input filters (same as arg for Star).
// Adds 4 new Scalar outputs for instantaneous motion output.
// Allocates an intermediate OutValue for 2-phase integration process.
// starting Scalar index returned.
func (vv *V1Vision) NewMotionFullField(in, fn int, geom *Geom) int {
	out := vv.NewScalar(4)
	op := vv.NewOp()
	op.Op = MotionFullField
	oy := int(geom.Out.Y - 1)
	op.RunN = uint32(2 * oy) // first pass N
	op.InValue = int32(in)
	op.OutValue = int32(vv.NewValues(oy, 1, 4))
	op.OutScalar = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

//gosl:start

// MotionIntegrate is the kernel.
func (op *Op) MotionIntegrate(i, ni int32) {
	fi := i % op.FilterN // inner
	pii := i / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	v := Values.Value(int(op.InValue), int(ni), int(yo), int(xo), int(pi), int(fi))
	f := Values.Value(int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(fi))
	s := Values.Value(int(op.OutValue+1), int(ni), int(yo), int(xo), int(pi), int(fi))

	if v > f {
		f = v
	} else {
		f += op.FloatArg1 * (v - f)
	}
	if v > s {
		s = v
	} else {
		s += op.FloatArg2 * (v - s)
	}

	Values.Set(f, int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(fi))
	Values.Set(s, int(op.OutValue+1), int(ni), int(yo), int(xo), int(pi), int(fi))
}

// MotionStar is the kernel.
func (op *Op) MotionStar(i, ni int32) {
	szX := op.Geom.Out.X - 1
	fi := i % op.FilterN // FilterN = orig fn * 2
	pii := i / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / szX
	xo := ii % szX

	fio := fi / 2 // original feature
	dir := fi % 2 // direction: left-right, down-up
	doff := fio*4 + dir*2

	var yoff, xoff int32 // offset to next (right or up)
	if dir == 0 {
		xoff = 1
	} else {
		yoff = 1
	}
	cf := Values.Value(int(op.InValue), int(ni), int(yo), int(xo), int(pi), int(fio))             // fast
	nf := Values.Value(int(op.InValue), int(ni), int(yo+yoff), int(xo+xoff), int(pi), int(fio))   // next
	cs := Values.Value(int(op.InValue+1), int(ni), int(yo), int(xo), int(pi), int(fio))           // slow
	ns := Values.Value(int(op.InValue+1), int(ni), int(yo+yoff), int(xo+xoff), int(pi), int(fio)) // next

	minact := min(min(min(cf, cs), nf), ns)
	cd := cf - cs
	nd := nf - ns
	v := op.FloatArg1 * (cd - nd)
	if v >= 0 { // delta bigger on current than next
		Values.Set(minact*v, int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(doff)) // 0 = left/down
		Values.Set(0.0, int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(doff+1))
	} else {
		Values.Set(-minact*v, int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(doff+1)) // 1 = right/up
		Values.Set(0.0, int(op.OutValue), int(ni), int(yo), int(xo), int(pi), int(doff))
	}
}

// MotionFullFieldX is the kernel: i = 2 * Y, first pass, FilterN = orig filtn
func MotionFullFieldX(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN*op.NData {
		return
	}
	ri := int32(i % op.RunN)
	ni := int32(i / op.RunN)
	szX := op.Geom.Out.X - 1
	fno := op.FilterN // original features
	dir := ri % 2
	yo := ri / 2
	doff := dir * 2

	csum := float32(0)
	nsum := float32(0)
	for xo := range szX {
		for pi := range 2 { // pos / neg
			for fi := range fno { // original features
				dfo := fi*4 + doff
				c := Values.Value(int(op.InValue), int(ni), int(yo), int(xo), int(pi), int(dfo))   // left, down
				n := Values.Value(int(op.InValue), int(ni), int(yo), int(xo), int(pi), int(dfo+1)) // right, up
				v := c - n
				if v >= 0 {
					csum += v
				} else {
					nsum += -v
				}
			}
		}
	}
	Values.Set(csum, int(op.OutValue), int(ni), int(yo), int(0), int(0), int(doff))
	Values.Set(nsum, int(op.OutValue), int(ni), int(yo), int(0), int(0), int(doff+1))
}

// MotionFullFieldY is the kernel: i = 2*NData, second pass
func MotionFullFieldY(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= 2*op.NData {
		return
	}
	ri := int32(i) % 2
	ni := int32(i) / 2
	szY := op.Geom.Out.Y - 1
	dir := ri
	doff := dir * 2
	csum := float32(0)
	nsum := float32(0)
	for y := range szY {
		c := Values.Value(int(op.OutValue), int(ni), int(y), int(0), int(0), int(doff))
		n := Values.Value(int(op.OutValue), int(ni), int(y), int(0), int(0), int(doff+1))
		csum += c
		nsum += n
	}
	Scalars.Set(csum, int(op.OutScalar+doff), int(ni))
	Scalars.Set(nsum, int(op.OutScalar+doff+1), int(ni))
}

//gosl:end
