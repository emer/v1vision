// Code generated by "goal build"; DO NOT EDIT.
//line kwta.goal:1
// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

import (
	"github.com/emer/v1vision/kwta"
)

// alias so it works locally too.
type KWTA = kwta.KWTA

// NewNeighInhib4 adds a [NeighInhib4] operation, from in value -> out value.
// fn is number of filters (innermost values dimension). must be 4!
// gi is inhibition strength.
// Output value has additional inhibition for active neighbors of same filter index.
// returns out index.
func (vv *V1Vision) NewNeighInhib4(in, fn int, gi float32, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for NeighInhib4!")
	}
	op := vv.NewOp()
	op.Op = NeighInhib4
	out := vv.NewNeighInhibOutput(fn, geom)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.FloatArg1 = gi
	op.Geom = *geom
	return out
}

// NewNeighInhibOutput add Values for a [NeighInhib] operation.
// fn is number of filters (innermost values dimension). returns out index.
func (vv *V1Vision) NewNeighInhibOutput(fn int, geom *Geom) int {
	return vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
}

// NewKWTA adds a [KWTAInhib] operation, on Values data.
// in = raw initial inputs, inExtGi = extra Gi inhibition
// typically from [NeighInhib4] -- if 0 then not used.
// fn is number of filters (innermost values dimension).
// geom.Out is the size of the outer Y,X dimensions, and
// FilterSz is the inner Y,X dimensions.
// Allocates a Inhibs to hold the inhibition compute values,
// including an additional Y row for the layer-level values at the end.
func (vv *V1Vision) NewKWTA(in, inExtGi, fn, kwtaIdx, inhIdx int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = KWTAInhib
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X)
	op.InValue = int32(in)
	op.InValue2 = int32(inExtGi)
	op.OutValue = int32(out)
	op.Inhibs = int32(inhIdx)
	op.FilterN = int32(fn)
	op.KWTA = int32(kwtaIdx)
	op.Geom = *geom
	return out
}

//gosl:start

// NeighInhib4 is kernel.
func (op *Op) NeighInhib4(i uint32) {
	ang := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	gi := float32(0)

	var ox, oy int32
	NeighInhibOffsets(ang, &ox, &oy)

	npX := xo + ox
	npY := yo + oy
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values.Value(int(op.InValue), int(npY), int(npX), int(pi), int(ang))
		gi = max(gi, v)
	}
	npX = xo - ox
	npY = yo - oy
	if npX >= 0 && npX < op.Geom.Out.X && npY >= 0 && npY < op.Geom.Out.Y {
		v := Values.Value(int(op.InValue), int(npY), int(npX), int(pi), int(ang))
		gi = max(gi, v)
	}
	Values.Set(op.FloatArg1*gi, int(op.OutValue), int(yo), int(xo), int(pi), int(ang))
}

// KWTAInitPool is the kernel to initialize KWTA process, on Values data.
// i = op.Geom.Out.Y * X. 2 x FilterN is inner 2 dims. Operates on Inhibs.
// InValue = raw initial activations (ge)
// OutValue = acts (output result)
func KWTAInitPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	yo := int32(i) / op.Geom.Out.X
	xo := int32(i) % op.Geom.Out.X

	pn := 2 * op.FilterN

	geAvg := float32(0)
	geMax := float32(0)
	for py := range 2 { // for 4D, FilterSz.Y
		for px := range op.FilterN {
			ge := Values.Value(int(op.InValue), int(yo), int(xo), int(py), int(px))
			geAvg += ge
			geMax = max(geMax, ge)
		}
	}

	for i := range InhibVarsN {
		Inhibs.Set(0.0, int(op.Inhibs), int(yo), int(xo), int(int(i)))
	}
	Inhibs.Set(geAvg/float32(pn), int(op.Inhibs), int(yo), int(xo), int(GeAvg))
	Inhibs.Set(geMax, int(op.Inhibs), int(yo), int(xo), int(GeMax))
}

// KWTAInitLayer is the kernel to initialize KWTA process for layer
// on Values data. Run = 1 only. Operates on Inhibs.
func KWTAInitLayer(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	lyi := op.Geom.Out.Y
	for i := range InhibVarsN {
		Inhibs.Set(0.0, int(op.Inhibs), int(lyi), int(0), int(int(i)))
	}
}

// KWTAIterLayerX is the kernel to iterate KWTA process at layer,
// first pass, operating on X dimension.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Inhibs updated from pool-level.
// Call this first then IterPool
func KWTAIterLayerX(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	yo := int32(i)
	if yo >= szY {
		return
	}
	ln := float32(szY)

	geAvg := float32(0)
	geMax := float32(0)
	actAvg := float32(0)
	actMax := float32(0)
	for xo := range szX {
		gavg := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(GeAvg))
		gmx := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(GeMax))
		aavg := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(ActAvg))
		amx := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(ActMax))
		geAvg += gavg
		geMax = max(geMax, gmx)
		actAvg += aavg
		actMax = max(actMax, amx)
	}
	geAvg /= ln
	actAvg /= ln
	Inhibs.Set(geAvg, int(op.Inhibs), int(yo), int(szX), int(GeAvg))
	Inhibs.Set(geMax, int(op.Inhibs), int(yo), int(szX), int(GeMax))
	Inhibs.Set(actAvg, int(op.Inhibs), int(yo), int(szX), int(ActAvg))
	Inhibs.Set(actMax, int(op.Inhibs), int(yo), int(szX), int(ActMax))
}

// KWTAIterLayerY is the kernel to iterate KWTA process at layer.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims.
// Operates on Inhibs updated from pool-level.
// Call this first then IterPool
func KWTAIterLayerY(i uint32) { //gosl:kernel
	if i != 0 {
		return
	}
	op := GetCurOp(0)
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	ln := float32(szY)

	geAvg := float32(0)
	geMax := float32(0)
	actAvg := float32(0)
	actMax := float32(0)
	for yo := range szY {
		gavg := Inhibs.Value(int(op.Inhibs), int(yo), int(szX), int(GeAvg))
		gmx := Inhibs.Value(int(op.Inhibs), int(yo), int(szX), int(GeMax))
		aavg := Inhibs.Value(int(op.Inhibs), int(yo), int(szX), int(ActAvg))
		amx := Inhibs.Value(int(op.Inhibs), int(yo), int(szX), int(ActMax))
		geAvg += gavg
		geMax = max(geMax, gmx)
		actAvg += aavg
		actMax = max(actMax, amx)
	}
	geAvg /= ln
	actAvg /= ln
	Inhibs.Set(geAvg, int(op.Inhibs), int(szY), int(0), int(GeAvg))
	Inhibs.Set(geMax, int(op.Inhibs), int(szY), int(0), int(GeMax))
	Inhibs.Set(actAvg, int(op.Inhibs), int(szY), int(0), int(ActAvg))
	Inhibs.Set(actMax, int(op.Inhibs), int(szY), int(0), int(ActMax))

	kp := GetKWTAs(uint32(op.KWTA))
	fbi := Inhibs.Value(int(op.Inhibs), int(szY), int(0), int(FBi))
	ffi := kp.Layer.FFInhib(geAvg, geMax)
	newFBi := kp.Layer.FBInhib(actAvg)
	fbi = kp.Layer.FBUpdt(fbi, newFBi)
	if kp.Layer.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}

	Inhibs.Set(ffi, int(op.Inhibs), int(szY), int(0), int(FFi))
	Inhibs.Set(fbi, int(op.Inhibs), int(szY), int(0), int(FBi))

	gi := kp.Layer.Gi * (ffi + fbi)
	Inhibs.Set(gi, int(op.Inhibs), int(szY), int(0), int(Gi))
	Inhibs.Set(gi, int(op.Inhibs), int(szY), int(0), int(GiOrig))
}

// KWTAIterPool is the kernel to iterate KWTA process for Pools.
// i = op.Geom.Out.Y * X. FilterSz is inner 2 dims. Operates on Inhibs.
// InValue = raw initial activations (ge)
// InValue2 = extra Gi values, if non-0
// OutValue = acts (output result)
func KWTAIterPool(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN {
		return
	}
	szY := op.Geom.Out.Y
	szX := op.Geom.Out.X
	yo := int32(i) / szX
	xo := int32(i) % szX

	layGi := Inhibs.Value(int(op.Inhibs), int(szY), int(0), int(Gi))
	kp := GetKWTAs(uint32(op.KWTA))

	pn := 2 * op.FilterN
	// pn := op.Geom.FilterSz.Y * op.Geom.FilterSz.X

	geAvg := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(GeAvg))
	geMax := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(GeMax))
	actAvg := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(ActAvg))
	fbi := Inhibs.Value(int(op.Inhibs), int(yo), int(xo), int(FBi))
	ffi := kp.Pool.FFInhib(geAvg, geMax)
	newFBi := kp.Pool.FBInhib(actAvg)
	fbi = kp.Pool.FBUpdt(fbi, newFBi)
	if kp.Pool.On.IsFalse() {
		ffi = float32(0.0)
		fbi = 0.0
	}

	Inhibs.Set(ffi, int(op.Inhibs), int(yo), int(xo), int(FFi))
	Inhibs.Set(fbi, int(op.Inhibs), int(yo), int(xo), int(FBi))

	gi := kp.Pool.Gi * (ffi + fbi)
	Inhibs.Set(gi, int(op.Inhibs), int(yo), int(xo), int(Gi))
	Inhibs.Set(gi, int(op.Inhibs), int(yo), int(xo), int(GiOrig))

	giPool := max(layGi, gi)

	actAvg = 0.0
	actMax := float32(0.0)
	for py := range 2 { // op.Geom.FilterSz.Y {
		for px := range op.FilterN {
			pgi := giPool
			if op.InValue2 > 0 {
				eIn := Values.Value(int(op.InValue2), int(yo), int(xo), int(py), int(px))
				eGi := kp.Pool.Gi * kp.Pool.FFInhib(eIn, eIn)
				pgi = max(pgi, eGi)
			}
			geThr := kp.GeThrFromG(pgi)
			ge := Values.Value(int(op.InValue), int(yo), int(xo), int(py), int(px))
			act := Values.Value(int(op.OutValue), int(yo), int(xo), int(py), int(px))
			geAvg += ge
			geMax = max(geMax, ge)
			delAct := float32(0)
			nwAct := kp.ActFromG(geThr, ge, act, &delAct)
			// maxDelAct = max(maxDelAct, math32.Abs(delAct)) // todo
			Values.Set(nwAct, int(op.OutValue), int(yo), int(xo), int(py), int(px))
			actAvg += nwAct
			actMax = max(actMax, nwAct)
		}
	}
	Inhibs.Set(actAvg/float32(pn), int(op.Inhibs), int(yo), int(xo), int(ActAvg))
	Inhibs.Set(actMax, int(op.Inhibs), int(yo), int(xo), int(ActMax))
}

// Neigh4X = []int{0, -1, 1, -1}
// Neigh4Y = []int{1, 1, 0, -1}

// ortho neighbor coordinates for 4 angles, also uses negated version
//
//	.
//
// --- = (0,1) (X,Y)
// . /
//
//	/  = (-1,1)
//
// | .  = (1,0)
//
//	\
//
// . \  = (-1,-1)
func NeighInhibOffsets(ang int32, ox, oy *int32) {
	switch ang {
	case 1, 3:
		*ox = -1
	case 2:
		*ox = 1
	default:
		*ox = 0
	}
	switch ang {
	case 0, 1:
		*oy = 1
	case 3:
		*oy = -1
	default:
		*oy = 0
	}
}

//gosl:end
