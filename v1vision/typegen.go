// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package v1vision

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.Geom", IDName: "geom", Doc: "Geom contains the filtering geometry info for a given filter pass.", Directives: []types.Directive{{Tool: "gosl", Directive: "start"}}, Fields: []types.Field{{Name: "In", Doc: "size of input -- computed from image or set"}, {Name: "Out", Doc: "size of output -- computed"}, {Name: "Border", Doc: "starting border into image -- must be >= FilterRt for images."}, {Name: "Spacing", Doc: "spacing -- number of pixels to skip in each direction"}, {Name: "FilterSize", Doc: "full size of filter"}, {Name: "FilterLt", Doc: "computed size of left/top size of filter"}, {Name: "FilterRt", Doc: "computed size of right/bottom size of filter (FilterSize - FilterLeft)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.GPUVars", IDName: "gpu-vars", Doc: "GPUVars is an enum for GPU variables, for specifying what to sync."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.InhibVars", IDName: "inhib-vars", Doc: "InhibVars are inhibition variables, stored in a tensor.Float32\nfor FFFB inhibition computations."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.KWTA", IDName: "kwta", Doc: "alias so it works locally too."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.Operations", IDName: "operations", Doc: "Operations are the operations that can be performed."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.Op", IDName: "op", Doc: "Op specifies an operation to perform.\nThe full computational sequence is specified as a sequence of operations.\nThis allows a full processing path to proceed with minimal transfers.", Fields: []types.Field{{Name: "Op", Doc: "Op is the operation to perform on this step"}, {Name: "RunN", Doc: "RunN is the total number of processors to deploy for this run\n(i.e., the loop N for data parallel for loop, logically)"}, {Name: "InImage", Doc: "InImage is the index of an image to process as an input."}, {Name: "InImageRGB", Doc: "InImageRGB is the RGB value to process of input image (0-2).\nIf 3, then all RGB are processed in one op (e.g., WrapPad)"}, {Name: "InValue", Doc: "InValue is the Values index input to use."}, {Name: "InValue2", Doc: "InValue2 is the second Values index input to use, where needed."}, {Name: "OutValue", Doc: "OutValue is the Values index output to write to."}, {Name: "OutValue4D", Doc: "OutValue4D is the Values4D index output to write to."}, {Name: "OutImage", Doc: "OutImage is the index of an image to send output for image ops."}, {Name: "OutImage2", Doc: "OutImage2 is the index of a second image to send output for image ops."}, {Name: "FilterType", Doc: "FilterType is the type index of Filters to use."}, {Name: "FilterN", Doc: "FilterN is the number of filters within the FilterType to use."}, {Name: "FloatArg1", Doc: "FloatArg1 is a float argument -- e.g., used for gain multiplier\nfactor to apply."}, {Name: "FloatArg2", Doc: "FloatArg2 is a float argument"}, {Name: "FloatArg3", Doc: "FloatArg3 is a float argument"}, {Name: "IntArg1", Doc: "IntArg1 is an arbitrary integer arg, used for different ops.\ne.g., PadWidth in WrapPad"}, {Name: "InScalar", Doc: "InScalar is the Scalars index input to read from."}, {Name: "OutScalar", Doc: "OutScalar is the Scalars index output to write to."}, {Name: "Inhibs", Doc: "Inhibs is the index of the Inhibs state variables to use."}, {Name: "KWTA", Doc: "KWTA is the index of the KWTA parameters to use."}, {Name: "Geom", Doc: "Geom is the geometry to use for this operation."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/v1vision/v1vision.V1Vision", IDName: "v1-vision", Doc: "V1Vision specifies a sequence of operations to perform on image\ninput data, to simulate V1-level visual processing.", Directives: []types.Directive{{Tool: "go", Directive: "generate", Args: []string{"core", "generate", "-add-types", "-gosl"}}}, Fields: []types.Field{{Name: "Ops", Doc: "Ops are the sequence of operations to perform, called in order."}, {Name: "CurOp", Doc: "CurOp is the current operation to perform."}, {Name: "KWTAs", Doc: "KWTAs are KWTA inhibition parameters that can be used."}, {Name: "Filters", Doc: "Filters are one general stack of rendered filters, sized to the max of each\nof the inner dimensional values: [FilterTypes][FilterN][Y][X]\nFilterTypes = different filter types (DoG, Gabor, etc)\nFilterN = number of filters within the group (On, Off, angle, etc)\nY, X = sizes."}, {Name: "Images", Doc: "Images are float-valued image data: [ImageNo][RGB][Y][X],\nsized to the max of each inner-dimensional value (RGB=3\nif more needed, use additional ImageNo)"}, {Name: "Values", Doc: "Values are intermediate input / output data: [ValueNo][Y][X][Polarity][FilterN]\nwhere FilterN corresponds to the different filters applied or other such data,\nand Polarity is 0 for positive (on) values and 1 for negative (off) values."}, {Name: "Values4D", Doc: "Values4D are 4D aggregated data (e.g., outputs):\n[ValueNo][PoolY][PoolX][UnitY][UnitX]"}, {Name: "Scalars", Doc: "Scalars are scalar values for Sum, Max summary stats.\nMore efficient to use these versus using large Values allocations."}, {Name: "Inhibs", Doc: "Inhibs are [KWTAInhib] inhibitory state values:\n[InhibNo][PoolY][PoolX][InhibVarsN]"}}})
