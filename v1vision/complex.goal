// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewLenSum4 adds a [LenSum4] operation, from in value -> out value.
// fn is number of filters (innermost values dimension) -- must be 4!.
// Operates on [MaxPolarity] output so only uses 0 polarity value.
// Output size is geom.Out, fn. Returns out index.
func (vv *V1Vision) NewLenSum4(in, fn int, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for LenSum4!")
	}
	op := vv.NewOp()
	op.Op = LenSum4
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn))
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

// NewEndStop4 adds a [EndStop4] operation, from in value -> out value.
// fn is number of filters (innermost values dimension) -- must be 4!.
// in = [MaxPolarity] output, inLenSum = output of [LenSum4] (required!)
// Output size is geom.Out, fn, with polarity = direction. Returns out index.
func (vv *V1Vision) NewEndStop4(in, inLenSum, fn int, geom *Geom) int {
	if fn != 4 {
		panic("only 4 angles are currently supported for EndStop4!")
	}
	op := vv.NewOp()
	op.Op = EndStop4
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in)
	op.InValue2 = int32(inLenSum)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

//gosl:start

// LenSum4 is kernel.
func (op *Op) LenSum4(i uint32) {
	szX := op.Geom.Out.X	
	szY := op.Geom.Out.Y
	ang := int32(i) % op.FilterN // inner
	ii := int32(i) / op.FilterN
	yo := ii / szX
	xo := ii % szY

	var ox, oy int32
	LenSumOffsets(ang, &ox, &oy)
	
	norm := float32(1) / 3
	ctr := Values[op.InValue, yo, xo, 0, ang]
	lp := float32(0)
	ln := float32(0)
	
	lpX := xo + ox
	lpY := yo + oy
	if lpX >= 0 && lpX < szX && lpY >= 0 && lpY < szY {
		lp = Values[op.InValue, lpY, lpX, 0, ang]
	}
	lnX := xo - ox
	lnY := yo - oy
	if lnX >= 0 && lnX < szX && lnY >= 0 && lnY < szY {
		ln = Values[op.InValue, lnY, lnX, 0, ang]
	}
	ls := norm * (ctr + lp + ln)
	Values[op.OutValue, yo, xo, 0, ang] = ls
}

// EndStop4 is kernel.
func (op *Op) EndStop4(i uint32) {
	szX := op.Geom.Out.X	
	szY := op.Geom.Out.Y
	ang := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / szX
	xo := ii % szX

	var ox, oy int32
	LenSumOffsets(ang, &ox, &oy)
	
	dsign := int32(1)
	if pi > 0 {
		dsign = -1
	}
	
	ls := float32(0)
	// length-sum point is "left" (negative) direction from ctr
	lnX := xo - dsign*ox
	lnY := yo - dsign*oy
	if lnX >= 0 && lnX < szX && lnY >= 0 && lnY < szY {
		ls = Values[op.InValue2, lnY, lnX, 0, ang]
	}
	
	offMax := float32(0)
	for oi := int32(0); oi < 3; oi++ {
		var ox, oy int32
		EndStopOffsets(ang, oi, &ox, &oy)
		ofX := xo + dsign*ox
		ofY := yo + dsign*oy
		if ofX >= 0 && ofX < szX && ofY >= 0 && ofY < szY {
			off := Values[op.InValue, ofY, ofX, 0, ang]
			offMax = max(offMax, off)
		}
	}
	es := ls - offMax // simple diff
	if es < 0.2 {     // note: builtin threshold
		es = 0
	}
	Values[op.OutValue, yo, xo, pi, ang] = es
}

// Line4X = []int{1, 1, 0, 1}
// Line4Y = []int{0, 1, 1, -1}

// linear neighbor coordinates for 4 angles, also uses negated version
// -- = (1,0) (X,Y)
// /  = (1,1)
// |  = (0,1)
// \  = (1,-1)
func LenSumOffsets(ang int32, ox, oy *int32) {
	switch ang {
	case 2:
		*ox = 0
	default:
		*ox = 1
	}
	switch ang {
	case 1, 2:
		*oy = 1
	case 3:
		*oy = -1
	default:
		*oy = 0
	}
}


// EndStopOff4X = []int{
// 	1, 1, 1,
// 	0, 1, 1,
// 	-1, 0, 1,
// 	0, 1, 1}
// EndStopOff4Y = []int{
// 	1, 0, -1,
// 	1, 1, 0,
// 	1, 1, 1,
// 	-1, -1, 0}

// end-stop off coordinates for 4 angles, also uses negated versions
// these go with the negative versions of Line4X (i.e., are in same dir)
// -- | = (1,1), (1,0), (1,-1) (X,Y)
// --|
// /  = (0,1), (1,1), (1,0)
// ---
//  |  = (-1,1), (0,1), (1,1)
// \   = (0,-1), (1,-1), (1,0)
// --|
func EndStopOffsets(ang, oi int32, ox, oy *int32) {
	i := ang*3 + oi
	switch i {
	case 6:
		*ox = -1
	case 3,7,9:
		*ox = 0
	default:
		*ox = 1
	}
	switch i {
	case 1,5,11:
		*oy = 0
	case 2,9,10:
		*oy = -1
	default:
		*oy = 1
	}
}


//gosl:end

