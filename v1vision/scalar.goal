// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewAggScalar adds a [SumScalar], [MeanScalar], or [MaxScalar] operation,
// which computes a [Scalars] output efficiently. Adds a Scalar output
// and returns index.
// in = input Values. Allocates output Values and scalars as needed.
// fn = number of filters, Geom Out sizes are used for indexing.
func (vv *V1Vision) NewAggScalar(aggOp Operations, in, fn int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = aggOp
	op.RunN = uint32(geom.Out.Y) // aggregate over Y
	op.InValue = int32(in)
	yout := vv.NewValues(int(geom.Out.Y), 1, 1) // intermediate y output
	op.OutValue = int32(yout)
	out := vv.NewScalar(1)
	op.OutScalar = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

//gosl:start

// note: multiple sub-steps for scalar integration is slower up to 512 x 512 v1gabor images

// const ScalarSteps = 2
// 
// func ScalarStart(i, n int32) int32 {
// 	ssz := n / ScalarSteps
// 	return i * ssz
// }
// 
// func ScalarEnd(i, n int32) int32 {
// 	ssz := n / ScalarSteps
// 	if i == n-1 {
// 		return n
// 	}
// 	return (i+1) * ssz
// }

// MaxScalarX is the first kernel for MaxScalar,
// operating over X rows.
func MaxScalarX(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN*op.NData {
		return
	}
	ri := int32(i % op.RunN)
	ni := int32(i / op.RunN)
	mx := float32(0)
	for x := range op.Geom.Out.X {
		for pi := range 2 {
			for fi := range op.FilterN {
				v := Values[op.InValue, ni, ri, x, pi, fi]
				mx = max(mx, v)
			}
		}
	}
	Values[op.OutValue, ni, ri, 0, 0, 0] = mx
}

// MaxScalarY is the second kernel for MaxScalar.
// operating over Y intermediate sum.
func MaxScalarY(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.NData {
		return
	}
	ni := int32(i)
	mx := float32(0)
	for y := range op.Geom.Out.Y {
		v := Values[op.OutValue, ni, y, 0, 0, 0]
		mx = max(mx, v)
	}
	Scalars[op.OutScalar, ni] = mx
}

// SumScalarX is the first kernel for SumScalar,
// operating over X rows.
func SumScalarX(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.RunN*op.NData {
		return
	}
	ri := int32(i % op.RunN)
	ni := int32(i / op.RunN)
	sum := float32(0)
	for x := range op.Geom.Out.X {
		for pi := range 2 {
			for fi := range op.FilterN {
				v := Values[op.InValue, ni, ri, x, pi, fi]
				sum += v
			}
		}
	}
	Values[op.OutValue, ni, ri, 0, 0, 0] = sum
}

// SumScalarY is the second kernel for SumScalar.
// operating over Y intermediate sum.
func SumScalarY(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.NData {
		return
	}
	ni := int32(i)
	sum := float32(0)
	for y := range op.Geom.Out.Y {
		v := Values[op.OutValue, ni, y, 0, 0, 0]
		sum += v
	}
	Scalars[op.OutScalar, ni] = sum
}

// MeanScalarY is the second kernel for MeanScalar.
// operating over Y intermediate sum.
func MeanScalarY(i uint32) { //gosl:kernel
	op := GetCurOp(0)
	if i >= op.NData {
		return
	}
	ni := int32(i)
	sum := float32(0)
	for y := range op.Geom.Out.Y {
		v := Values[op.OutValue, ni, y, 0, 0, 0]
		sum += v
	}
	sum /= float32(op.Geom.Out.Y * op.Geom.Out.X * op.FilterN * 2)
	Scalars[op.OutScalar, ni] = sum
}

//gosl:end

