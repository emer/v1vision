// Code generated by "goal build"; DO NOT EDIT.
//line convolve.goal:1
// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewConvolveImage adds a [ConvolveImage] operation,
// operating on given image input index and rgb pane,
// and given filter type and number of filters, applying given gain factor.
// Adds a output values of shape [geom.Out.Y, .X, 2, fn] and returns index.
// The input Image *must* have border (padding) so that filters are
// applied without any bounds checking: wrapping etc is all
// done in the padding process, which is much more efficient.
func (vv *V1Vision) NewConvolveImage(in, irgb, ftyp, fn int, gain float32, geom *Geom) int {
	op := vv.NewOp()
	op.Op = ConvolveImage
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn))
	op.InImage = int32(in)
	op.InImageRGB = int32(irgb)
	op.OutValue = int32(out)
	op.FilterType = int32(ftyp)
	op.FilterN = int32(fn)
	op.FloatArg1 = gain
	op.Geom = *geom
	return out
}

//gosl:start

// ConvolveImage is the kernel for Convolve on Image data.
func (op *Op) ConvolveImage(i uint32) {
	fi := int32(i) % op.FilterN // inner
	ii := int32(i) / op.FilterN
	yo := ii / op.Geom.Out.X
	xo := ii % op.Geom.Out.X

	istX := op.Geom.Border.X - op.Geom.FilterLt.X
	istY := op.Geom.Border.Y - op.Geom.FilterLt.Y
	yi := int(istY + yo*op.Geom.Spacing.Y)
	xi := int(istX + xo*op.Geom.Spacing.X)

	fyn := int(op.Geom.FilterSz.Y)
	fxn := int(op.Geom.FilterSz.X)
	sum := float32(0)
	for fy := 0; fy < fyn; fy++ {
		for fx := 0; fx < fxn; fx++ {
			iv := Images.Value(int(op.InImage), int(op.InImageRGB), int(yi+fy), int(xi+fx))
			fv := Filters.Value(int(op.FilterType), int(fi), int(fy), int(fx))
			sum += fv * iv
		}
	}
	sum *= op.FloatArg1
	if sum > 0 {
		Values.Set(sum, int(op.OutValue), int(yo), int(xo), int(0), int(fi))
		Values.Set(0.0, int(op.OutValue), int(yo), int(xo), int(1), int(fi))
	} else {
		Values.Set(0.0, int(op.OutValue), int(yo), int(xo), int(0), int(fi))
		Values.Set(-sum, int(op.OutValue), int(yo), int(xo), int(1), int(fi))
	}
}

//gosl:end
