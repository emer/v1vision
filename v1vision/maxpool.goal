// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

// NewMaxPool adds a [MaxPool] operation, from in value -> out values.
// fn is number of filters (innermost values dimension),
// pn is number of polarities (1 or 2),
// geom.In is the size of the input values, and geom.Out is the output,
// where geom is: Out = (In / Spacing), and FilterSize <= Spacing.
// (e.g., use geom.SetFilter). returns index of new output.
func (vv *V1Vision) NewMaxPool(in, pn, fn int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = MaxPool
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * int32(pn))
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.IntArg1 = int32(pn)
	op.Geom = *geom
	return out
}

// NewMaxPolarity adds a [MaxPolarity] operation, from in value -> out values.
// fn is number of filters (innermost values dimension).
// geom.Out is the size of both input and output,
// just maxes over the polarity dimension. returns index of new output.
func (vv *V1Vision) NewMaxPolarity(in, fn int, geom *Geom) int {
	op := vv.NewOp()
	op.Op = MaxPolarity
	out := vv.NewValues(int(geom.Out.Y), int(geom.Out.X), fn)
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn))
	op.InValue = int32(in)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
	return out
}

// NewMaxCopy adds a [MaxCopy] operation, as max(in1, in2) values -> out values.
// fn is number of filters (innermost values dimension).
// geom.Out is the size of the input and output values.
// Must create output in advance to support multi-max (max on prior max).
func (vv *V1Vision) NewMaxCopy(in1, in2, out, fn int, geom *Geom) {
	op := vv.NewOp()
	op.Op = MaxCopy
	op.RunN = uint32(geom.Out.Y * geom.Out.X * int32(fn) * 2)
	op.InValue = int32(in1)
	op.InValue2 = int32(in2)
	op.OutValue = int32(out)
	op.FilterN = int32(fn)
	op.Geom = *geom
}

//gosl:start

// MaxPool is kernel.
func (op *Op) MaxPool(i uint32) {
	szX := op.Geom.Out.X
	fY := op.Geom.FilterSize.Y	
	fX := op.Geom.FilterSize.X
	
	fi := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % op.IntArg1 // plus-minus
	ii := pii / op.IntArg1
	yo := ii / szX
	xo := ii % szX

	iy := yo * op.Geom.Spacing.Y
	ix := xo * op.Geom.Spacing.X

	mx := float32(0)
	for py := range fY {
		for px := range fX {
			iv := Values[op.InValue, iy+py, ix+px, pi, fi]
			if iv > mx {
				mx = iv
			}
		}
	}
	Values[op.OutValue, yo, xo, pi, fi] = mx
}

// MaxPolarity is kernel.
func (op *Op) MaxPolarity(i uint32) {
	szX := op.Geom.Out.X
	fi := int32(i) % op.FilterN // inner
	ii := int32(i) / op.FilterN
	yo := ii / szX
	xo := ii % szX

	mx := float32(0)
	for pi := range 2 {
		iv := Values[op.InValue, yo, xo, pi, fi]
		if iv > mx {
			mx = iv
		}
	}
	Values[op.OutValue, yo, xo, 0, fi] = mx
}

// MaxCopy is kernel.
func (op *Op) MaxCopy(i uint32) {
	szX := op.Geom.Out.X
	fi := int32(i) % op.FilterN // inner
	pii := int32(i) / op.FilterN
	pi := pii % 2 // plus-minus
	ii := pii / 2
	yo := ii / szX
	xo := ii % szX

	i1 := Values[op.InValue, yo, xo, pi, fi]
	i2 := Values[op.InValue2, yo, xo, pi, fi]
	Values[op.OutValue, yo, xo, pi, fi] = max(i1, i2)
}

//gosl:end

