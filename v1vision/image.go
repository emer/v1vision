// Code generated by "goal build"; DO NOT EDIT.
//line image.goal:1
// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package v1vision

import (
	"image"
	"image/color"

	"cogentcore.org/core/colors"
	"cogentcore.org/lab/tensor"
	"github.com/emer/v1vision/colorspace"
)

const (
	// TopZero is arg to pass to image routines to put Y=0 at top of tensors.
	// Default is bottom.
	TopZero = true

	// BottomZero is arg to pass to image routines to put Y=0 at bottom of tensors.
	// This is the default.
	BottomZero = false
)

// NewWrapImage configures a new WrapPad operation for given input image
// and RGB index (3 = all). Output goes to another image.
// padWidth is the border padding around edges.
func (vv *V1Vision) NewWrapImage(in, irgb, out, padWidth int, geom *Geom) {
	op := vv.NewOp()
	op.Op = WrapPad
	nin := geom.In.Y * geom.In.X
	if irgb == 3 {
		nin *= 3
	}
	op.RunN = uint32(nin)
	op.InImage = int32(in)
	op.InImageRGB = int32(irgb)
	op.OutImage = int32(out)
	op.IntArg1 = int32(padWidth)
	op.Geom = *geom
}

// NewFadeImage configures a new FadePad operation for given input image
// and RGB index (3 = all). Output goes to another image.
// padWidth is the border padding around edges. r,g,b are edge average
// values that are faded into (can set FloatArg1-3 values later too).
// Returns the index of Op
func (vv *V1Vision) NewFadeImage(in, irgb, out, padWidth int, r, g, b float32, geom *Geom) int {
	op := vv.NewOp()
	op.Op = FadePad
	nin := geom.In.Y * geom.In.X
	if irgb == 3 {
		nin *= 3
	}
	op.RunN = uint32(nin)
	op.InImage = int32(in)
	op.InImageRGB = int32(irgb)
	op.OutImage = int32(out)
	op.IntArg1 = int32(padWidth)
	op.Geom = *geom
	fidx := len(vv.Ops) - 1
	vv.SetFadeRGB(fidx, r, g, b)
	return fidx
}

// SetFadeRGB sets the fade color for FadePad
func (vv *V1Vision) SetFadeRGB(fadeIdx int, r, g, b float32) {
	op := &vv.Ops[fadeIdx]
	op.FloatArg1 = r
	op.FloatArg2 = g
	op.FloatArg3 = b
}

// NewLMSImage configures a new LMSImage operation for given input image,
// setting output index 0 = grey, 1 = RedGreen, 2 = BlueYellow.
// gain is a multiplier factor for the color contrasts relative to grey
// because they tend to be weaker.
func (vv *V1Vision) NewLMSImage(in, out int, gain float32, geom *Geom) {
	op := vv.NewOp()
	op.Op = LMSImage
	nin := geom.In.Y * geom.In.X
	op.RunN = uint32(nin)
	op.InImage = int32(in)
	op.OutImage = int32(out)
	op.FloatArg1 = gain
	op.Geom = *geom
}

//gosl:start
//gosl:import "github.com/emer/v1vision/colorspace"

// WrapPad is the kernel for WrapPad.
// wraps given padding width of float32 image around sides
// i.e., padding for left side of image is the (mirrored) bits
// from the right side of image, etc.
func (op *Op) WrapPad(i uint32) {
	ii := int32(i)
	ri := op.InImageRGB
	if ri == 3 {
		xy := op.Geom.In.X * op.Geom.In.Y
		ri = int32(i) / xy
		ii = int32(i) % xy
	}
	y := ii / op.Geom.In.X
	x := ii % op.Geom.In.X
	padWidth := op.IntArg1
	uY := op.Geom.In.Y - padWidth
	uX := op.Geom.In.X - padWidth
	sy := y
	if y < padWidth {
		sy = uY - (padWidth - y)
	} else if y >= uY {
		sy = padWidth + (y - uY)
	}
	sx := x
	if x < padWidth {
		sx = uX - (padWidth - x)
	} else if x >= uX {
		sx = padWidth + (x - uX)
	}
	iv := Images.Value(int(op.InImage), int(ri), int(sy), int(sx))
	Images.Set(iv, int(op.OutImage), int(ri), int(y), int(x))
}

// FadePad is the kernel for FadePad.
// wraps given padding width of float32 image around sides
// i.e., padding for left side of image is the (mirrored) bits
// from the right side of image, etc.
func (op *Op) FadePad(i uint32) {
	ii := int32(i)
	ri := op.InImageRGB
	avg := op.FloatArg1
	if ri == 3 {
		xy := op.Geom.In.X * op.Geom.In.Y
		ri = int32(i) / xy
		ii = int32(i) % xy
		switch ri {
		case 0:
			avg = op.FloatArg1
		case 1:
			avg = op.FloatArg2
		case 2:
			avg = op.FloatArg3
		default:
		}
	}
	y := ii / op.Geom.In.X
	x := ii % op.Geom.In.X
	padWidth := op.IntArg1
	uY := op.Geom.In.Y - padWidth
	uX := op.Geom.In.X - padWidth
	sy := y
	p := float32(1)
	if y < padWidth {
		p = float32(y) / float32(padWidth)
		sy = uY - (padWidth - y)
	} else if y >= uY {
		p = 1.0 - float32(y-uY)/float32(padWidth)
		sy = padWidth + (y - uY)
	}
	sx := x
	if x < padWidth {
		p = min(p, float32(x)/float32(padWidth))
		sx = uX - (padWidth - x)
	} else if x >= uX {
		p = min(p, 1.0-float32(x-uX)/float32(padWidth))
		sx = padWidth + (x - uX)
	}
	pavg := (1.0 - p) * avg
	iv := Images.Value(int(op.InImage), int(ri), int(sy), int(sx))
	Images.Set(p*iv+pavg, int(op.OutImage), int(ri), int(y), int(x))
}

// LMSImage is the kernel for LMSImage.
func (op *Op) LMSImage(i uint32) {
	ii := int32(i)
	y := ii / op.Geom.In.X
	x := ii % op.Geom.In.X

	r := Images.Value(int(op.InImage), int(0), int(y), int(x))
	g := Images.Value(int(op.InImage), int(1), int(y), int(x))
	b := Images.Value(int(op.InImage), int(2), int(y), int(x))

	var lvm, svlm, grey float32
	colorspace.SRGBToLMSOppos(r, g, b, &lvm, &svlm, &grey)

	Images.Set(grey, int(op.OutImage), int(0), int(y), int(x))
	Images.Set(op.FloatArg1*lvm, int(op.OutImage), int(1), int(y), int(x))
	Images.Set(op.FloatArg1*svlm, int(op.OutImage), int(2), int(y), int(x))
}

//gosl:end

// RGBToTensor converts an RGB input image to an RGB tensor
// with outer dimension as RGB components.
// padWidth is the amount of padding to add on all sides.
// topZero retains the Y=0 value at the top of the tensor --
// otherwise it is flipped with Y=0 at the bottom to be consistent
// with the emergent / OpenGL standard coordinate system
func RGBToTensor(img image.Image, tsr *tensor.Float32, padWidth int, topZero bool) {
	bd := img.Bounds()
	sz := bd.Size()
	tsr.SetShapeSizes(3, sz.Y+2*padWidth, sz.X+2*padWidth)
	for y := 0; y < sz.Y; y++ {
		for x := 0; x < sz.X; x++ {
			sy := y
			if !topZero {
				sy = (sz.Y - 1) - y
			}
			cv := img.At(bd.Min.X+x, bd.Min.Y+sy)
			r, g, b, _ := colors.ToFloat32(cv)
			tsr.Set(r, 0, y+padWidth, x+padWidth)
			tsr.Set(g, 1, y+padWidth, x+padWidth)
			tsr.Set(b, 2, y+padWidth, x+padWidth)
		}
	}
}

// RGBTensorToImage converts an RGB tensor to image -- uses
// existing image if it is of correct size, otherwise makes a new one.
// tensor must have outer dimension as RGB components.
// padWidth is the amount of padding to subtract from all sides.
// topZero retains the Y=0 value at the top of the tensor --
// otherwise it is flipped with Y=0 at the bottom to be consistent
// with the emergent / OpenGL standard coordinate system
func RGBTensorToImage(img *image.RGBA, tsr *tensor.Float32, padWidth int, topZero bool) *image.RGBA {
	var sz image.Point
	sz.Y = tsr.DimSize(1) - 2*padWidth
	sz.X = tsr.DimSize(2) - 2*padWidth
	if img == nil {
		img = image.NewRGBA(image.Rectangle{Max: sz})
	} else {
		isz := img.Bounds().Size()
		if isz != sz {
			img = image.NewRGBA(image.Rectangle{Max: sz})
		}
	}
	for y := 0; y < sz.Y; y++ {
		for x := 0; x < sz.X; x++ {
			sy := y
			if !topZero {
				sy = (sz.Y - 1) - y
			}
			r := tsr.Value(0, y+padWidth, x+padWidth)
			g := tsr.Value(1, y+padWidth, x+padWidth)
			b := tsr.Value(2, y+padWidth, x+padWidth)
			ri := uint8(r * 255)
			gi := uint8(g * 255)
			bi := uint8(b * 255)
			img.Set(x, sy, color.RGBA{ri, gi, bi, 255})
		}
	}
	return img
}

// RGBToGrey converts an RGB input image to a greyscale tensor
// in preparation for processing. Writes to first (red) component.
// padWidth is the amount of padding to add on all sides.
// topZero retains the Y=0 value at the top of the tensor --
// otherwise it is flipped with Y=0 at the bottom to be consistent
// with the emergent standard coordinate system.
// Tensor must already be set to source size + 2*padWidth!
func RGBToGrey(img image.Image, tsr *tensor.Float32, padWidth int, topZero bool) {
	bd := img.Bounds()
	sz := bd.Size()
	for y := 0; y < sz.Y; y++ {
		for x := 0; x < sz.X; x++ {
			sy := y
			if !topZero {
				sy = (sz.Y - 1) - y
			}
			cv := img.At(bd.Min.X+x, bd.Min.Y+sy)
			r, g, b, _ := colors.ToFloat32(cv)
			gv := (r + g + b) / 3
			tsr.Set(gv, 0, y+padWidth, x+padWidth)
		}
	}
}

// GreyTensorToImage converts a greyscale tensor to image -- uses
// existing img if it is of correct size, otherwise makes a new one.
// padWidth is the amount of padding to subtract from all sides.
// topZero retains the Y=0 value at the top of the tensor --
// otherwise it is flipped with Y=0 at the bottom to be consistent
// with the emergent / OpenGL standard coordinate system
func GreyTensorToImage(img *image.Gray, tsr *tensor.Float32, padWidth int, topZero bool) *image.Gray {
	var sz image.Point
	sz.Y = tsr.DimSize(0) - 2*padWidth
	sz.X = tsr.DimSize(1) - 2*padWidth
	if img == nil {
		img = image.NewGray(image.Rectangle{Max: sz})
	} else {
		isz := img.Bounds().Size()
		if isz != sz {
			img = image.NewGray(image.Rectangle{Max: sz})
		}
	}
	for y := 0; y < sz.Y; y++ {
		for x := 0; x < sz.X; x++ {
			sy := y
			if !topZero {
				sy = (sz.Y - 1) - y
			}
			cv := tsr.Value(y+padWidth, x+padWidth)
			iv := uint8(cv * 255)
			img.Set(x, sy, color.Gray{iv})
		}
	}
	return img
}

// EdgeAvg returns the average value around the effective edge of RGB image
// at padWidth in from each side
func EdgeAvg(tsr *tensor.Float32, padWidth int) (r, g, b float32) {
	sz := image.Point{tsr.DimSize(2), tsr.DimSize(1)}
	esz := sz
	esz.X -= 2 * padWidth
	esz.Y -= 2 * padWidth
	var avg [3]float32
	n := 0
	for y := 0; y < esz.Y; y++ {
		oy := y + padWidth
		for rgb := range 3 {
			avg[rgb] += tsr.Value(rgb, oy, padWidth)
			avg[rgb] += tsr.Value(rgb, oy, padWidth+esz.X-1)
		}
	}
	n += 2 * esz.X
	for x := 0; x < esz.X; x++ {
		ox := x + padWidth
		for rgb := range 3 {
			avg[rgb] += tsr.Value(rgb, padWidth, ox)
			avg[rgb] += tsr.Value(rgb, padWidth+esz.Y-1, ox)
		}
	}
	n += 2 * esz.X
	r = avg[0] / float32(n)
	g = avg[1] / float32(n)
	b = avg[2] / float32(n)
	return
}
