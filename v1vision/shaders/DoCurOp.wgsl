// Code generated by "gosl"; DO NOT EDIT
// kernel: DoCurOp

// // CurOp is the current operation to perform. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> CurOp: array<Op>;
// // Filters are one general stack of rendered filters, sized to the max of each // of the inner dimensional values: [FilterTypes][FilterN][Y][X] // FilterTypes = different filter types (DoG, Gabor, etc) // FilterN = number of filters within the group (On, Off, angle, etc) // Y, X = sizes. 
@group(1) @binding(0)
var<storage, read> Filters: array<f32>;
// // Images are float-valued image data: // [ImageNo][NData][RGB][Y][X], // sized to the max of each inner-dimensional value (RGB=3, // if more needed, use additional ImageNo) 
@group(2) @binding(0)
var<storage, read_write> Images: array<f32>;
@group(2) @binding(1)
var<storage, read_write> Values: array<f32>;
@group(2) @binding(2)
var<storage, read_write> Values4D: array<f32>;
@group(2) @binding(3)
var<storage, read_write> Scalars: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	DoCurOp(idx);
}

fn Index4D(s0: u32, s1: u32, s2: u32, s3: u32, i0: u32, i1: u32, i2: u32, i3: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3;
}

fn Index5D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4;
}

fn Index6D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, s5: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32, i5: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4 + s5 * i5;
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "vars.go"

//////// import: "colorspace-lms.go"
/*
func LMSToXYZ_CAT02(l, m, s f32) (x, y, z f32) {
    x = 1.096124 * l + 0.4296f * Y + -0.1624f * Z;
    y = -0.7036f * X + 1.6975f * Y + 0.0061f * Z;
    z = 0.0030f * X + 0.0136f * Y + 0.9834 * Z;
  }
*/
fn SRGBLinToLMS_HPE(rl: f32,gl: f32,bl: f32, l: ptr<function,f32>,m: ptr<function,f32>,s: ptr<function,f32>) {
	*l = 0.30567503*rl + 0.62274014*gl + 0.04530167*bl;
	*m = 0.15771291*rl + 0.7697197*gl + 0.08807348*bl;
	*s = 0.0193*rl + 0.1192*gl + 0.9505*bl;
}
fn SRGBToLMS_HPE(r: f32,g: f32,b: f32, l: ptr<function,f32>,m: ptr<function,f32>,s: ptr<function,f32>) {
	var rl: f32;
	var gl: f32;
	var bl: f32;
	SRGBToLinear(r, g, b, &rl, &gl, &bl);
	SRGBLinToLMS_HPE(rl, gl, bl, l, m, s);
}
/*
  func LMStoXYZ_HPE(float& X, float& Y, float& Z,
                                    L, M, S) {
    X = 1.096124f * L + 0.4296f * Y + -0.1624f * Z;
    Y = -0.7036f * X + 1.6975f * Y + 0.0061f * Z;
    Z = 0.0030f * X + 0.0136f * Y + 0.9834 * Z;
  }
*/
fn ResponseCompression(val: f32) -> f32 {
	var pval = pow(val, 0.42);
	var rc = 0.1 + 4.0*pval/(27.13+pval);
return rc;
}
fn LMSToComps(l: f32,m: f32,s: f32, lc: ptr<function,f32>,mc: ptr<function,f32>,sc: ptr<function,f32>,lmc: ptr<function,f32>,lvm: ptr<function,f32>,svlm: ptr<function,f32>,grey: ptr<function,f32>) {
	var lrc = ResponseCompression(l);
	var mrc = ResponseCompression(m);
	var src = ResponseCompression(s);
	*lc = 6.0 * ((lrc + (1.0/11.0)*src) - 0.109091);
	*mc = 6.0 * (((12.0 / 11.0) * mrc) - 0.109091);
	*lvm = *lc - *mc; // red-green subtracting "criterion for unique yellow"
	*lmc = 6.0 * (((1.0 / 9.0) * (lrc + mrc)) - 0.0222222);
	*sc = 6.0 * (((2.0 / 9.0) * src) - 0.0222222);
	*svlm = *sc - *lmc; // blue-yellow contrast
	*grey = (1.0 / 0.431787) * (2.0*lrc + mrc + .05*src - 0.305);
return;
}

//////// import: "colorspace-srgb.go"
fn SRGBToLinearComp(srgb: f32) -> f32 {
	if (srgb <= 0.04045) {
		return srgb / 12.92;
	}return pow((srgb+0.055)/1.055, 2.4);
}
fn SRGBToLinear(r: f32,g: f32,b: f32, rl: ptr<function,f32>,gl: ptr<function,f32>,bl: ptr<function,f32>) {
	*rl = SRGBToLinearComp(r);
	*gl = SRGBToLinearComp(g);
	*bl = SRGBToLinearComp(b);
}
fn SRGBToLMSAll(r: f32,g: f32,b: f32, lc: ptr<function,f32>,mc: ptr<function,f32>,sc: ptr<function,f32>,lmc: ptr<function,f32>,lvm: ptr<function,f32>,svlm: ptr<function,f32>,grey: ptr<function,f32>) {
	var l: f32;
	var m: f32;
	var s: f32;
	SRGBToLMS_HPE(r, g, b, &l, &m, &s); // note: HPE
	LMSToComps(l, m, s, lc, mc, sc, lmc, lvm, svlm, grey);
}

//////// import: "complex.go"
fn Op_LenSum4(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x;
	var szY = op.Geom.Out.y;
	var ang = i % op.FilterN; // inner
	var ii = i / op.FilterN;
	var yo = ii / szX;
	var xo = ii % szX;
	var ox: i32;
	var oy: i32;
	LenSumOffsets(ang, &ox, &oy);
	var norm = f32(1) / 3;
	var ctr = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(0), u32(ang))];
	var lp = f32(0);
	var ln = f32(0);
	var lpX = xo + ox;
	var lpY = yo + oy;
	if (lpX >= 0 && lpX < szX && lpY >= 0 && lpY < szY) {
		lp = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(lpY), u32(lpX), u32(0), u32(ang))];
	}
	var lnX = xo - ox;
	var lnY = yo - oy;
	if (lnX >= 0 && lnX < szX && lnY >= 0 && lnY < szY) {
		ln = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(lnY), u32(lnX), u32(0), u32(ang))];
	}
	var ls = norm * (ctr + lp + ln);
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(ang))] = ls;
}
fn Op_EndStop4(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x;
	var szY = op.Geom.Out.y;
	var ang = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / szX;
	var xo = ii % szX;
	var ox: i32;
	var oy: i32;
	LenSumOffsets(ang, &ox, &oy);
	var dsign = i32(1);
	if (pi > 0) {
		dsign = i32(-1);
	}
	var ls = f32(0);
	var lnX = xo - dsign*ox;
	var lnY = yo - dsign*oy;
	if (lnX >= 0 && lnX < szX && lnY >= 0 && lnY < szY) {
		ls = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue2), u32(ni), u32(lnY), u32(lnX), u32(0), u32(ang))];
	}
	var offMax = f32(0);
	for (var oi = i32(0);
	 oi < 3; oi++) {
		var ox: i32;
		var oy: i32;
		EndStopOffsets(ang, oi, &ox, &oy);
		var ofX = xo + dsign*ox;
		var ofY = yo + dsign*oy;
		if (ofX >= 0 && ofX < szX && ofY >= 0 && ofY < szY) {
			var off = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(ofY), u32(ofX), u32(0), u32(ang))];
			offMax = max(offMax, off);
		}
	}
	var es = ls - offMax; // simple diff
	if (es < 0.2) {       // note: builtin threshold
		es = f32(0);
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(ang))] = es;
}
fn LenSumOffsets(ang: i32, ox: ptr<function,i32>,oy: ptr<function,i32>) {
	switch (ang) {
	case 2: {
		*ox = i32(0);
	}
	default: {
		*ox = i32(1);
	}
	}
	switch (ang) {
	case 1, 2: {
		*oy = i32(1);
	}
	case 3: {
		*oy = i32(-1);
	}
	default: {
		*oy = i32(0);
	}
	}
}
fn EndStopOffsets(ang: i32,oi: i32, ox: ptr<function,i32>,oy: ptr<function,i32>) {
	var i = ang*3 + oi;
	switch (i) {
	case 6: {
		*ox = i32(-1);
	}
	case 3, 7, 9: {
		*ox = i32(0);
	}
	default: {
		*ox = i32(1);
	}
	}
	switch (i) {
	case 1, 5, 11: {
		*oy = i32(0);
	}
	case 2, 9, 10: {
		*oy = i32(-1);
	}
	default: {
		*oy = i32(1);
	}
	}
}

//////// import: "convolve.go"
fn Op_ConvolveImage(op: Op, i: i32,ni: i32) {
	var fi = i % op.FilterN; // inner
	var ii = i / op.FilterN;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var istX = op.Geom.Border.x - op.Geom.FilterLt.x;
	var istY = op.Geom.Border.y - op.Geom.FilterLt.y;
	var yi = i32(istY + yo*op.Geom.Spacing.y);
	var xi = i32(istX + xo*op.Geom.Spacing.x);
	var fyn = i32(op.Geom.FilterSize.y);
	var fxn = i32(op.Geom.FilterSize.x);
	var sum = f32(0);
	for (var fy=0; fy<fyn; fy++) {
		for (var fx=0; fx<fxn; fx++) {
			var iv = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(op.InImageRGB), u32(yi + fy), u32(xi + fx))];
			var fv = Filters[Index4D(TensorStrides[0], TensorStrides[1], TensorStrides[2], TensorStrides[3], u32(op.FilterType), u32(fi), u32(fy), u32(fx))];
			sum += fv * iv;
		}
	}
	sum *= op.FloatArg1;
	if (sum > 0) {
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(fi))] = sum;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(1), u32(fi))] = 0.0;
	} else {
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(fi))] = 0.0;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
		TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(1), u32(fi))] = -sum;
	}
}
fn Op_ConvolveDiff(op: Op, i: i32,ni: i32) {
	var yo = i / op.Geom.Out.x;
	var xo = i % op.Geom.Out.x;
	var fi = op.OutScalar;
	var istX = op.Geom.Border.x - op.Geom.FilterLt.x;
	var istY = op.Geom.Border.y - op.Geom.FilterLt.y;
	var yi = i32(istY + yo*op.Geom.Spacing.y);
	var xi = i32(istX + xo*op.Geom.Spacing.x);
	var fyn = i32(op.Geom.FilterSize.y);
	var fxn = i32(op.Geom.FilterSize.x);
	var sumOn = f32(0);
	var sumOff = f32(0);
	for (var fy=0; fy<fyn; fy++) {
		for (var fx=0; fx<fxn; fx++) {
			var iv1 = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(op.InImageRGB), u32(yi + fy), u32(xi + fx))];
			var iv2 = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InValue2), u32(ni), u32(op.OutImage2), u32(yi + fy), u32(xi + fx))];
			var fv1 = Filters[Index4D(TensorStrides[0], TensorStrides[1], TensorStrides[2], TensorStrides[3], u32(op.FilterType), u32(op.FilterN), u32(fy), u32(fx))];
			var fv2 = Filters[Index4D(TensorStrides[0], TensorStrides[1], TensorStrides[2], TensorStrides[3], u32(op.FilterType), u32(op.IntArg1), u32(fy), u32(fx))];
			sumOn += fv1 * iv1;
			sumOff += fv2 * iv2;
		}
	}
	var diff = op.FloatArg1 * (op.FloatArg2*sumOn - sumOff);
	if (diff > 0) {
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(fi))] = diff;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(1), u32(fi))] = 0.0;
	} else {
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(1), u32(fi))] = -diff;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(fi))] = 0.0;
	}
}

//////// import: "enumgen.go"
const GPUVarsN: GPUVars = 8;
const InhibVarsN: InhibVars = 9;
const OperationsN: Operations = 23;

//////// import: "fffb-fffb.go"
struct FFFB {
	On: i32,
	Gi: f32,
	FF: f32,
	FB: f32,
	FBTau: f32,
	MaxVsAvg: f32,
	FF0: f32,
	FBDt: f32,
}

//////// import: "geom.go"
struct Geom {
	In: vec4<i32>,
	Out: vec4<i32>,
	Border: vec4<i32>,
	Spacing: vec4<i32>,
	FilterSize: vec4<i32>,
	FilterLt: vec4<i32>,
	FilterRt: vec4<i32>,
}

//////// import: "image.go"
fn Op_WrapPad(op: Op, i: i32,ni: i32) {
	var ii = i;
	var ri = op.InImageRGB;
	if (ri == 3) {
		var xy = op.Geom.In.x * op.Geom.In.y;
		ri = i / xy;
		ii = i % xy;
	}
	var y = ii / op.Geom.In.x;
	var x = ii % op.Geom.In.x;
	var padWidth = op.IntArg1;
	var uY = op.Geom.In.y - padWidth;
	var uX = op.Geom.In.x - padWidth;
	var sy = y;
	if (y < padWidth) {
		sy = uY - (padWidth - y);
	} else if (y >= uY) {
		sy = padWidth + (y - uY);
	}
	var sx = x;
	if (x < padWidth) {
		sx = uX - (padWidth - x);
	} else if (x >= uX) {
		sx = padWidth + (x - uX);
	}
	var iv = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(ri), u32(sy), u32(sx))];
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13],
	TensorStrides[14], u32(op.OutImage), u32(ni), u32(ri), u32(y), u32(x))] = iv;
}
fn Op_FadePad(op: Op, i: i32,ni: i32) {
	var ii = i;
	var ri = op.InImageRGB;
	var avg = op.FloatArg1;
	if (ri == 3) {
		var xy = op.Geom.In.x * op.Geom.In.y;
		ri = i / xy;
		ii = i % xy;
		switch (ri) {
		case 0: {
			avg = op.FloatArg1;
		}
		case 1: {
			avg = op.FloatArg2;
		}
		case 2: {
			avg = op.FloatArg3;
		}
		default: {
		}
		}
	}
	var y = ii / op.Geom.In.x;
	var x = ii % op.Geom.In.x;
	var padWidth = op.IntArg1;
	var uY = op.Geom.In.y - padWidth;
	var uX = op.Geom.In.x - padWidth;
	var sy = y;
	var p = f32(1);
	if (y < padWidth) {
		p = f32(y) / f32(padWidth);
		sy = uY - (padWidth - y);
	} else if (y >= uY) {
		p = 1.0 - f32(y-uY)/f32(padWidth);
		sy = padWidth + (y - uY);
	}
	var sx = x;
	if (x < padWidth) {
		p = min(p, f32(x)/f32(padWidth));
		sx = uX - (padWidth - x);
	} else if (x >= uX) {
		p = min(p, 1.0-f32(x-uX)/f32(padWidth));
		sx = padWidth + (x - uX);
	}
	var pavg = (1.0 - p) * avg;
	var iv = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(ri), u32(sy), u32(sx))];
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13],
	TensorStrides[14], u32(op.OutImage), u32(ni), u32(ri), u32(y), u32(x))] = p*iv + pavg;
}
fn Op_LMSOpponents(op: Op, i: i32,ni: i32) {
	var y = i / op.Geom.In.x;
	var x = i % op.Geom.In.x;
	var r = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(0), u32(y), u32(x))];
	var g = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(1), u32(y), u32(x))];
	var b = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(2), u32(y), u32(x))];
	var lc: f32;
	var mc: f32;
	var sc: f32;
	var lmc: f32;
	var lvm: f32;
	var svlm: f32;
	var grey: f32;
	SRGBToLMSAll(r, g, b, &lc, &mc, &sc, &lmc, &lvm, &svlm, &grey);
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // RedGreen
	TensorStrides[14], u32(op.OutImage), u32(ni), u32(0), u32(y), u32(x))] = op.FloatArg1 * lvm;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.OutImage), u32(ni), u32(1), u32(y), u32(x))] = grey;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // BlueYellow
	TensorStrides[14],
	u32(op.OutImage), u32(ni), u32(2), u32(y), u32(x))] = op.FloatArg1 * svlm;
}
fn Op_LMSComponents(op: Op, i: i32,ni: i32) {
	var y = i / op.Geom.In.x;
	var x = i % op.Geom.In.x;
	var r = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(0), u32(y), u32(x))];
	var g = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(1), u32(y), u32(x))];
	var b = Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.InImage), u32(ni), u32(2), u32(y), u32(x))];
	var lc: f32;
	var mc: f32;
	var sc: f32;
	var lmc: f32;
	var lvm: f32;
	var svlm: f32;
	var grey: f32;
	SRGBToLMSAll(r, g, b, &lc, &mc, &sc, &lmc, &lvm, &svlm, &grey);
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // Red
	TensorStrides[14], u32(op.OutImage), u32(ni), u32(0), u32(y), u32(x))] = op.FloatArg1 * lc;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // Green
	TensorStrides[14], u32(op.OutImage), u32(ni), u32(1), u32(y), u32(x))] = op.FloatArg1 * mc;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.OutImage), u32(ni), u32(2), u32(y), u32(x))] = grey;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // Yellow
	TensorStrides[14], u32(op.OutImage2), u32(ni), u32(0), u32(y), u32(x))] = op.FloatArg1 * lmc;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], TensorStrides[14], u32(op.OutImage2), u32(ni), u32(1), u32(y), u32(x))] = grey;
	Images[Index5D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], // Blue
	TensorStrides[14], u32(op.OutImage2), u32(ni), u32(2), u32(y), u32(x))] = op.FloatArg1 * sc;
}

//////// import: "inhib.go"
alias InhibVars = i32; //enums:enum
const  FFi: InhibVars = 0;
const  FBi: InhibVars = 1;
const  Gi: InhibVars = 2;
const  GiOrig: InhibVars = 3;
const  LayGi: InhibVars = 4;
const  GeAvg: InhibVars = 5;
const  GeMax: InhibVars = 6;
const  ActAvg: InhibVars = 7;
const  ActMax: InhibVars = 8;

//////// import: "kwta-chans.go"
struct Chans {
	E: f32,
	L: f32,
	I: f32,
	K: f32,
}

//////// import: "kwta-kwta.go"
struct KWTA {
	On: i32,
	Iters: i32,
	DelActThr: f32,
	ActTau: f32,
	Layer: FFFB,
	Pool: FFFB,
	XX1: Params,
	Gbar: Chans,
	Erev: Chans,
	ErevSubThr: Chans,
	ThrSubErev: Chans,
	ActDt: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}

//////// import: "kwta.go"
fn Op_NeighInhib4(op: Op, i: i32,ni: i32) {
	var ang = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var gi = f32(0);
	var ox: i32;
	var oy: i32;
	NeighInhibOffsets(ang, &ox, &oy);
	var npX = xo + ox;
	var npY = yo + oy;
	if (npX >= 0 && npX < op.Geom.Out.x && npY >= 0 && npY < op.Geom.Out.y) {
		var v = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(npY), u32(npX), u32(pi), u32(ang))];
		gi = max(gi, v);
	}
	npX = xo - ox;
	npY = yo - oy;
	if (npX >= 0 && npX < op.Geom.Out.x && npY >= 0 && npY < op.Geom.Out.y) {
		var v = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(npY), u32(npX), u32(pi), u32(ang))];
		gi = max(gi, v);
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24],
	TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(ang))] = op.FloatArg1 * gi;
}
fn NeighInhibOffsets(ang: i32, ox: ptr<function,i32>,oy: ptr<function,i32>) {
	switch (ang) {
	case 1, 3: {
		*ox = i32(-1);
	}
	case 2: {
		*ox = i32(1);
	}
	default: {
		*ox = i32(0);
	}
	}
	switch (ang) {
	case 0, 1: {
		*oy = i32(1);
	}
	case 3: {
		*oy = i32(-1);
	}
	default: {
		*oy = i32(0);
	}
	}
}

//////// import: "logrenorm.go"
fn Op_LogValues(op: Op, i: i32,ni: i32) {
	var fi = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var lg = op.FloatArg1 * log(1.0+Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))]);
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = lg;
}
fn Op_NormDiv(op: Op, i: i32,ni: i32) {
	var fi = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var sc = Scalars[Index2D(TensorStrides[40], TensorStrides[41], u32(op.InScalar), u32(ni))];
	var v = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	if (sc != 0) {
		v /= sc;
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = v;
}

//////// import: "math32-fastexp.go"

//////// import: "maxpool.go"
fn Op_MaxPool(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x;
	var fY = op.Geom.FilterSize.y;
	var fX = op.Geom.FilterSize.x;
	var fi = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % op.IntArg1; // plus-minus
	var ii = pii / op.IntArg1;
	var yo = ii / szX;
	var xo = ii % szX;
	var iy = yo * op.Geom.Spacing.y;
	var ix = xo * op.Geom.Spacing.x;
	var mx = f32(0);
	for (var py=0; py<fY; py++) {
		for (var px=0; px<fX; px++) {
			var iv = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(iy + py), u32(ix + px), u32(pi), u32(fi))];
			if (iv > mx) {
				mx = iv;
			}
		}
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = mx;
}
fn Op_MaxPolarity(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x;
	var fi = i % op.FilterN; // inner
	var ii = i / op.FilterN;
	var yo = ii / szX;
	var xo = ii % szX;
	var mx = f32(0);
	for (var pi=0; pi<2; pi++) {
		var iv = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
		if (iv > mx) {
			mx = iv;
		}
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(0), u32(fi))] = mx;
}
fn Op_MaxCopy(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x;
	var fi = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / szX;
	var xo = ii % szX;
	var i1 = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	var i2 = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue2), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = max(i1, i2);
}

//////// import: "motion.go"
fn Op_MotionIntegrate(op: Op, i: i32,ni: i32) {
	var fi = i % op.FilterN; // inner
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var v = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	var f = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	var s = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue + 1), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	if (v > f) {
		f = v;
	} else {
		f += op.FloatArg1 * (v - f);
	}
	if (v > s) {
		s = v;
	} else {
		s += op.FloatArg2 * (v - s);
	}
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = f;
	Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], TensorStrides[25], u32(op.OutValue + 1), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))] = s;
}
fn Op_MotionStar(op: Op, i: i32,ni: i32) {
	var szX = op.Geom.Out.x - 1;
	var fi = i % op.FilterN; // FilterN = orig fn * 2
	var pii = i / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / szX;
	var xo = ii % szX;
	var fio = fi / 2; // original feature
	var dir = fi % 2; // direction: left-right, down-up
	var doff = fio*4 + dir*2;
	var yoff: i32;
	var // offset to next (right or up)
	xoff: i32;
	if (dir == 0) {
		xoff = i32(1);
	} else {
		yoff = i32(1);
	}
	var cf = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], // fast
	TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fio))];
	var nf = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], // next
	TensorStrides[25], u32(op.InValue), u32(ni), u32(yo + yoff), u32(xo + xoff), u32(pi), u32(fio))];
	var cs = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], // slow
	TensorStrides[25], u32(op.InValue + 1), u32(ni), u32(yo), u32(xo), u32(pi), u32(fio))];
	var ns = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], // next
	TensorStrides[25], u32(op.InValue + 1), u32(ni), u32(yo + yoff), u32(xo + xoff), u32(pi), u32(fio))];
	var minact = min(min(min(cf, cs), nf), ns);
	var cd = cf - cs;
	var nd = nf - ns;
	var v = op.FloatArg1 * (cd - nd);
	if (v >= 0) { // delta bigger on current than next
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // 0 = left/down
		TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(doff))] = minact * v;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(doff + 1))] = 0.0;
	} else {
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], // 1 = right/up
		TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(doff + 1))] = -minact * v;
		Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24],
		TensorStrides[25], u32(op.OutValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(doff))] = 0.0;
	}
}

//////// import: "nxx1-nxx1.go"
struct Params {
	Thr: f32,
	Gain: f32,
	NVar: f32,
	VmActThr: f32,
	SigMult: f32,
	SigMultPow: f32,
	SigGain: f32,
	InterpRange: f32,
	GainCorRange: f32,
	GainCor: f32,
	SigGainNVar: f32,
	SigMultEff: f32,
	SigValAt0: f32,
	InterpVal: f32,
	pad: f32,
	pad1: f32,
}

//////// import: "op.go"
alias Operations = i32; //enums:enum
const  NoOp: Operations = 0;
const  WrapPad: Operations = 1;
const  FadePad: Operations = 2;
const  LMSOpponents: Operations = 3;
const  LMSComponents: Operations = 4;
const  ConvolveImage: Operations = 5;
const  ConvolveDiff: Operations = 6;
const  LogValues: Operations = 7;
const  MaxScalar: Operations = 8;
const  SumScalar: Operations = 9;
const  MeanScalar: Operations = 10;
const  NormDiv: Operations = 11;
const  NeighInhib4: Operations = 12;
const  KWTAInhib: Operations = 13;
const  MaxPool: Operations = 14;
const  MaxPolarity: Operations = 15;
const  MaxCopy: Operations = 16;
const  LenSum4: Operations = 17;
const  EndStop4: Operations = 18;
const  To4D: Operations = 19;
const  MotionIntegrate: Operations = 20;
const  MotionStar: Operations = 21;
const  MotionFullField: Operations = 22;
struct Op {
	Op: Operations,
	NData: u32,
	RunN: u32,
	InImage: i32,
	InImageRGB: i32,
	InValue: i32,
	InValue2: i32,
	OutValue: i32,
	OutValue4D: i32,
	OutImage: i32,
	OutImage2: i32,
	FilterType: i32,
	FilterN: i32,
	FloatArg1: f32,
	FloatArg2: f32,
	FloatArg3: f32,
	IntArg1: i32,
	InScalar: i32,
	OutScalar: i32,
	Inhibs: i32,
	KWTA: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
	Geom: Geom,
}
fn Op_Run(op: Op, ri: i32,ni: i32) {
	switch (op.Op) {
	case ConvolveImage: {
		Op_ConvolveImage(op, ri, ni);
	}
	case ConvolveDiff: {
		Op_ConvolveDiff(op, ri, ni);
	}
	case WrapPad: {
		Op_WrapPad(op, ri, ni);
	}
	case FadePad: {
		Op_FadePad(op, ri, ni);
	}
	case LMSOpponents: {
		Op_LMSOpponents(op, ri, ni);
	}
	case LMSComponents: {
		Op_LMSComponents(op, ri, ni);
	}
	case LogValues: {
		Op_LogValues(op, ri, ni);
	}
	case NormDiv: {
		Op_NormDiv(op, ri, ni);
	}
	case NeighInhib4: {
		Op_NeighInhib4(op, ri, ni);
	}
	case MaxPool: {
		Op_MaxPool(op, ri, ni);
	}
	case MaxPolarity: {
		Op_MaxPolarity(op, ri, ni);
	}
	case MaxCopy: {
		Op_MaxCopy(op, ri, ni);
	}
	case LenSum4: {
		Op_LenSum4(op, ri, ni);
	}
	case EndStop4: {
		Op_EndStop4(op, ri, ni);
	}
	case To4D: {
		Op_To4D(op, ri, ni);
	}
	case MotionIntegrate: {
		Op_MotionIntegrate(op, ri, ni);
	}
	case MotionStar: {
		Op_MotionStar(op, ri, ni);
	}
	default: {
	}
	}
}
fn DoCurOp(i: u32) { //gosl:kernel
	let op = CurOp[0];
	if (i >= op.RunN*op.NData) {
		return;
	}
	var ri = i32(i % op.RunN);
	var ni = i32(i / op.RunN);
	Op_Run(op, ri, ni);
}

//////// import: "scalar.go"

//////// import: "to4d.go"
fn Op_To4D(op: Op, i: i32,ni: i32) {
	var fY = op.Geom.FilterSize.y;
	var fX = op.Geom.FilterSize.x;
	var szX = op.Geom.Out.x;
	var fi = i % fX;
	var pii = i / fX;
	var pi = pii % fY; // polarity
	var ii = pii / fY;
	var yo = ii / szX;
	var xo = ii % szX;
	var toY = op.IntArg1;
	var iv = Values[Index6D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], TensorStrides[25], u32(op.InValue), u32(ni), u32(yo), u32(xo), u32(pi), u32(fi))];
	Values4D[Index6D(TensorStrides[30], TensorStrides[31], TensorStrides[32], TensorStrides[33], TensorStrides[34], TensorStrides[35], u32(op.OutValue4D), u32(ni), u32(yo), u32(xo), u32(toY + pi), u32(fi))] = iv;
}