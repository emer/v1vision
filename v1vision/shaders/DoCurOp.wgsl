// Code generated by "gosl"; DO NOT EDIT
// kernel: DoCurOp

// // CurOp is the current operation to perform. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> CurOp: array<Op>;
// // Filters are one general stack of rendered filters, sized to the max of each // of the inner dimensional values: [FilterTypes][FilterN][Y][X] // FilterTypes = different filter types (DoG, Gabor, etc) // FilterN = number of filters within the group (On, Off, angle, etc) // Y, X = sizes. 
@group(1) @binding(0)
var<storage, read> Filters: array<f32>;
// // Images are float-valued image data: [ImageNo][RGB][Y][X], // sized to the max of each inner-dimensional value (RGB=3, // if more needed, use additional ImageNo) 
@group(2) @binding(0)
var<storage, read_write> Images: array<f32>;
@group(2) @binding(1)
var<storage, read_write> Values: array<f32>;
@group(2) @binding(3)
var<storage, read_write> Scalars: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	DoCurOp(idx);
}

fn Index4D(s0: u32, s1: u32, s2: u32, s3: u32, i0: u32, i1: u32, i2: u32, i3: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3;
}

fn Index5D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4;
}

fn Index1D(s0: u32, i0: u32) -> u32 {
	return s0 * i0;
}


//////// import: "vars.go"

//////// import: "convolve.go"
fn Op_ConvolveImage(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var ii = i32(i) / op.FilterN;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var istX = op.Geom.Border.x - op.Geom.FilterLt.x;
	var istY = op.Geom.Border.y - op.Geom.FilterLt.y;
	var yi = i32(istY + yo*op.Geom.Spacing.y);
	var xi = i32(istX + xo*op.Geom.Spacing.x);
	var fyn = i32(op.Geom.FilterSz.y);
	var fxn = i32(op.Geom.FilterSz.x);
	var sum = f32(0);
	for (var fy = 0; fy < fyn; fy++) {
		for (var fx = 0; fx < fxn; fx++) {
			var iv = Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.InImage), u32(op.InImageRGB), u32(yi + fy), u32(xi + fx))];
			var fv = Filters[Index4D(TensorStrides[0], TensorStrides[1], TensorStrides[2], TensorStrides[3], u32(op.FilterType), u32(fi), u32(fy), u32(fx))];
			sum += fv * iv;
		}
	}
	sum *= op.FloatArg1;
	if (sum > 0) {
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(0), u32(fi))] = sum;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(1), u32(fi))] = 0.0;
	} else {
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(0), u32(fi))] = 0.0;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(1), u32(fi))] = -sum;
	}
}

//////// import: "enumgen.go"
const GPUVarsN: GPUVars = 7;
const InhibVarsN: InhibVars = 9;
const OperationsN: Operations = 14;

//////// import: "fffb-fffb.go"
struct FFFB {
	On: i32,
	Gi: f32,
	FF: f32,
	FB: f32,
	FBTau: f32,
	MaxVsAvg: f32,
	FF0: f32,
	FBDt: f32,
}

//////// import: "geom.go"
struct Geom {
	In: vec4<i32>,
	Out: vec4<i32>,
	Border: vec4<i32>,
	Spacing: vec4<i32>,
	FilterSz: vec4<i32>,
	FilterLt: vec4<i32>,
	FilterRt: vec4<i32>,
}

//////// import: "image.go"
fn Op_WrapPad(op: Op, i: u32) {
	var ii = i32(i);
	var ri = op.InImageRGB;
	if (ri == 3) {
		var xy = op.Geom.In.x * op.Geom.In.y;
		ri = i32(i) / xy;
		ii = i32(i) % xy;
	}
	var y = ii / op.Geom.In.x;
	var x = ii % op.Geom.In.x;
	var padWidth = op.IntArg1;
	var uY = op.Geom.In.y - padWidth;
	var uX = op.Geom.In.x - padWidth;
	var sy = y;
	if (y < padWidth) {
		sy = uY - (padWidth - y);
	} else if (y >= uY) {
		sy = padWidth + (y - uY);
	}
	var sx = x;
	if (x < padWidth) {
		sx = uX - (padWidth - x);
	} else if (x >= uX) {
		sx = padWidth + (x - uX);
	}
	var iv = Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.InImage), u32(ri), u32(sy), u32(sx))];
	Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.OutImage), u32(ri), u32(y), u32(x))] = iv;
}

//////// import: "inhib.go"
alias InhibVars = i32; //enums:enum
const  FFi: InhibVars = 0;
const  FBi: InhibVars = 1;
const  Gi: InhibVars = 2;
const  GiOrig: InhibVars = 3;
const  LayGi: InhibVars = 4;
const  GeAvg: InhibVars = 5;
const  GeMax: InhibVars = 6;
const  ActAvg: InhibVars = 7;
const  ActMax: InhibVars = 8;

//////// import: "kwta-chans.go"
struct Chans {
	E: f32,
	L: f32,
	I: f32,
	K: f32,
}

//////// import: "kwta-kwta.go"
struct KWTA {
	On: i32,
	Iters: i32,
	DelActThr: f32,
	ActTau: f32,
	LayFFFB: FFFB,
	PoolFFFB: FFFB,
	XX1: Params,
	Gbar: Chans,
	Erev: Chans,
	ErevSubThr: Chans,
	ThrSubErev: Chans,
	ActDt: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}

//////// import: "kwta.go"

//////// import: "logrenorm.go"
fn Op_LogValues(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var pii = i32(i) / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var lg = op.FloatArg1 * log(1.0+Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(pi), u32(fi))]);
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(fi))] = lg;
}
fn Op_NormDiv(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var pii = i32(i) / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var sc = Scalars[Index1D(TensorStrides[40], u32(op.InScalar))];
	var v = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(pi), u32(fi))];
	if (sc != 0) {
		v /= sc;
	}
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(fi))] = v;
}

//////// import: "maxpool.go"
fn Op_MaxPool(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var pii = i32(i) / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var iy = yo * op.Geom.Spacing.y;
	var ix = xo * op.Geom.Spacing.x;
	var mx = f32(0);
	for (var py=0; py<op.Geom.FilterSz.y; py++) {
		for (var px=0; px<op.Geom.FilterSz.x; px++) {
			var iv = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(iy + py), u32(ix + px), u32(pi), u32(fi))];
			if (iv > mx) {
				mx = iv;
			}
		}
	}
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(fi))] = mx;
}

//////// import: "motion.go"
fn Op_MotionIntegrate(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var pii = i32(i) / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var v = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(pi), u32(fi))];
	var f = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(fi))];
	var s = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue + 1), u32(yo), u32(xo), u32(pi), u32(fi))];
	if (v > f) {
		f = v;
	} else {
		f += op.FloatArg1 * (v - f);
	}
	if (v > s) {
		s = v;
	} else {
		s += op.FloatArg2 * (v - s);
	}
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(fi))] = f;
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
	TensorStrides[24], u32(op.OutValue + 1), u32(yo), u32(xo), u32(pi), u32(fi))] = s;
}
fn Op_MotionStar(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // FilterN = orig fn * 2
	var pii = i32(i) / op.FilterN;
	var pi = pii % 2; // plus-minus
	var ii = pii / 2;
	var yo = ii / (op.Geom.Out.x - 1);
	var xo = ii % (op.Geom.Out.x - 1);
	var fio = fi / 2; // original feature
	var dir = fi % 2; // direction: left-right, down-up
	var doff = fio*4 + dir*2;
	var yoff: i32;
	var // offset to next (right or up)
	xoff: i32;
	if (dir == 0) {
		xoff = i32(1);
	} else {
		yoff = i32(1);
	}
	var cf = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // fast
	TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(pi), u32(fio))];
	var nf = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // next
	TensorStrides[24], u32(op.InValue), u32(yo + yoff), u32(xo + xoff), u32(pi), u32(fio))];
	var cs = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // slow
	TensorStrides[24], u32(op.InValue + 1), u32(yo), u32(xo), u32(pi), u32(fio))];
	var ns = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // next
	TensorStrides[24], u32(op.InValue + 1), u32(yo + yoff), u32(xo + xoff), u32(pi), u32(fio))];
	var minact = min(min(min(cf, cs), nf), ns);
	var cd = cf - cs;
	var nd = nf - ns;
	var v = op.FloatArg1 * (cd - nd);
	if (v >= 0) { // delta bigger on current than next
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // 0 = left/down
		TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(doff))] = minact * v;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(doff + 1))] = 0.0;
	} else {
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], // 1 = right/up
		TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(doff + 1))] = -minact * v;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23],
		TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(pi), u32(doff))] = 0.0;
	}
}

//////// import: "nxx1-nxx1.go"
struct Params {
	Thr: f32,
	Gain: f32,
	NVar: f32,
	VmActThr: f32,
	SigMult: f32,
	SigMultPow: f32,
	SigGain: f32,
	InterpRange: f32,
	GainCorRange: f32,
	GainCor: f32,
	SigGainNVar: f32,
	SigMultEff: f32,
	SigValAt0: f32,
	InterpVal: f32,
	pad: f32,
	pad1: f32,
}

//////// import: "op.go"
alias Operations = i32; //enums:enum
const  NoOp: Operations = 0;
const  WrapPad: Operations = 1;
const  ConvolveImage: Operations = 2;
const  LogValues: Operations = 3;
const  MaxScalar: Operations = 4;
const  SumScalar: Operations = 5;
const  MeanScalar: Operations = 6;
const  NormDiv: Operations = 7;
const  NeighInhib: Operations = 8;
const  KWTAInhib: Operations = 9;
const  MaxPool: Operations = 10;
const  MotionIntegrate: Operations = 11;
const  MotionStar: Operations = 12;
const  MotionFullField: Operations = 13;
struct Op {
	Op: Operations,
	RunN: u32,
	InImage: i32,
	InImageRGB: i32,
	InValue: i32,
	OutValue: i32,
	OutImage: i32,
	FilterType: i32,
	FilterN: i32,
	FloatArg1: f32,
	FloatArg2: f32,
	IntArg1: i32,
	InScalar: i32,
	OutScalar: i32,
	KWTA: i32,
	pad: i32,
	Geom: Geom,
}
fn Op_Run(op: Op, i: u32) {
	switch (op.Op) {
	case ConvolveImage: {
		Op_ConvolveImage(op, i);
	}
	case WrapPad: {
		Op_WrapPad(op, i);
	}
	case LogValues: {
		Op_LogValues(op, i);
	}
	case NormDiv: {
		Op_NormDiv(op, i);
	}
	case MaxPool: {
		Op_MaxPool(op, i);
	}
	case MotionIntegrate: {
		Op_MotionIntegrate(op, i);
	}
	case MotionStar: {
		Op_MotionStar(op, i);
	}
	default: {
	}
	}
}
fn DoCurOp(i: u32) { //gosl:kernel
	let op = CurOp[0];
	if (i >= op.RunN) {
		return;
	}
	Op_Run(op, i);
}