// Code generated by "gosl"; DO NOT EDIT
// kernel: KWTAIterPool

// // CurOp is the current operation to perform. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> CurOp: array<Op>;
@group(0) @binding(2)
var<storage, read> KWTAs: array<KWTA>;
// // Filters are one general stack of rendered filters, sized to the max of each // of the inner dimensional values: [FilterTypes][FilterN][Y][X] // FilterTypes = different filter types (DoG, Gabor, etc) // FilterN = number of filters within the group (On, Off, angle, etc) // Y, X = sizes. 
// // Images are float-valued image data: [ImageNo][RGB][Y][X], // sized to the max of each inner-dimensional value (RGB=3, // if more needed, use additional ImageNo) 
@group(2) @binding(1)
var<storage, read_write> Values: array<f32>;
@group(2) @binding(4)
var<storage, read_write> Inhibs: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	KWTAIterPool(idx);
}

fn Index5D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4;
}

fn Index4D(s0: u32, s1: u32, s2: u32, s3: u32, i0: u32, i1: u32, i2: u32, i3: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3;
}


//////// import: "vars.go"

//////// import: "colorspace-lms.go"
alias LMSComponents = i32; //enums:enum
const  LC: LMSComponents = 0;
const  MC: LMSComponents = 1;
const  SC: LMSComponents = 2;
const  LMC: LMSComponents = 3;
const  LvMC: LMSComponents = 4;
const  SvLMC: LMSComponents = 5;
const  GREY: LMSComponents = 6;
alias Opponents = i32; //enums:enum
const  WhiteBlack: Opponents = 0;
const  RedGreen: Opponents = 1;
const  BlueYellow: Opponents = 2;
/*
func LMSToXYZ_CAT02(l, m, s f32) (x, y, z f32) {
    x = 1.096124 * l + 0.4296f * Y + -0.1624f * Z;
    y = -0.7036f * X + 1.6975f * Y + 0.0061f * Z;
    z = 0.0030f * X + 0.0136f * Y + 0.9834 * Z;
  }
*/
/*
  func LMStoXYZ_HPE(float& X, float& Y, float& Z,
                                    L, M, S) {
    X = 1.096124f * L + 0.4296f * Y + -0.1624f * Z;
    Y = -0.7036f * X + 1.6975f * Y + 0.0061f * Z;
    Z = 0.0030f * X + 0.0136f * Y + 0.9834 * Z;
  }
*/

//////// import: "colorspace-srgb.go"

//////// import: "complex.go"

//////// import: "convolve.go"

//////// import: "enumgen.go"
const GPUVarsN: GPUVars = 8;
const InhibVarsN: InhibVars = 9;
const OperationsN: Operations = 20;

//////// import: "fffb-fffb.go"
struct FFFB {
	On: i32,
	Gi: f32,
	FF: f32,
	FB: f32,
	FBTau: f32,
	MaxVsAvg: f32,
	FF0: f32,
	FBDt: f32,
}
fn FFFB_FFInhib(fb: FFFB, avgGe: f32,maxGe: f32) -> f32 {
	var ffNetin = avgGe + fb.MaxVsAvg*(maxGe-avgGe);
	var ffi: f32;
	if (ffNetin > fb.FF0) {
		ffi = fb.FF * (ffNetin - fb.FF0);
	}return ffi;
}
fn FFFB_FBInhib(fb: FFFB, avgAct: f32) -> f32 {
	return fb.FB * avgAct;
}
fn FFFB_FBUpdt(fb: FFFB, fbi: f32, newFbi: f32) -> f32 {
	var nfb = fbi;
	nfb += fb.FBDt * (newFbi - nfb);return nfb;
}

//////// import: "geom.go"
struct Geom {
	In: vec4<i32>,
	Out: vec4<i32>,
	Border: vec4<i32>,
	Spacing: vec4<i32>,
	FilterSz: vec4<i32>,
	FilterLt: vec4<i32>,
	FilterRt: vec4<i32>,
}

//////// import: "image.go"

//////// import: "inhib.go"
alias InhibVars = i32; //enums:enum
const  FFi: InhibVars = 0;
const  FBi: InhibVars = 1;
const  Gi: InhibVars = 2;
const  GiOrig: InhibVars = 3;
const  LayGi: InhibVars = 4;
const  GeAvg: InhibVars = 5;
const  GeMax: InhibVars = 6;
const  ActAvg: InhibVars = 7;
const  ActMax: InhibVars = 8;

//////// import: "kwta-chans.go"
struct Chans {
	E: f32,
	L: f32,
	I: f32,
	K: f32,
}

//////// import: "kwta-kwta.go"
struct KWTA {
	On: i32,
	Iters: i32,
	DelActThr: f32,
	ActTau: f32,
	Layer: FFFB,
	Pool: FFFB,
	XX1: Params,
	Gbar: Chans,
	Erev: Chans,
	ErevSubThr: Chans,
	ThrSubErev: Chans,
	ActDt: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn KWTA_GeThrFromG(kp: KWTA, gi: f32) -> f32 {
	var ge = ((kp.Gbar.I*gi*kp.ErevSubThr.I + kp.Gbar.L*kp.ErevSubThr.L) / kp.ThrSubErev.E);return ge;
}
fn KWTA_ActFromG(kp: KWTA, geThr: f32,ge: f32,act: f32, delAct: ptr<function,f32>) -> f32 {
	var nwAct = Params_NoisyXX1(kp.XX1, ge*kp.Gbar.E - geThr);
	*delAct = kp.ActDt * (nwAct - act);
	nwAct = act + *delAct;return nwAct;
}

//////// import: "kwta.go"
fn KWTAIterPool(i: u32) { //gosl:kernel
	let op = CurOp[0];
	if (i >= op.RunN) {
		return;
	}
	var szY = op.Geom.Out.y;
	var szX = op.Geom.Out.x;
	var yo = i32(i) / szX;
	var xo = i32(i) % szX;
	var layGi = Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(szY), u32(0), u32(Gi))];
	let kp = KWTAs[u32(op.KWTA)];
	var pn = 2 * op.FilterN;
	var geAvg = Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(GeAvg))];
	var geMax = Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(GeMax))];
	var actAvg = Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(ActAvg))];
	var fbi = Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(FBi))];
	var ffi = FFFB_FFInhib(kp.Pool, geAvg, geMax);
	var newFBi = FFFB_FBInhib(kp.Pool, actAvg);
	fbi = FFFB_FBUpdt(kp.Pool, fbi, newFBi);
	if (kp.Pool.On == 0) {
		ffi = f32(0.0);
		fbi = f32(0.0);
	}
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(FFi))] = ffi;
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(FBi))] = fbi;
	var gi = kp.Pool.Gi * (ffi + fbi);
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(Gi))] = gi;
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(GiOrig))] = gi;
	var giPool = max(layGi, gi);
	actAvg = f32(0.0);
	var actMax = f32(0.0);
	for (var py=0; py<2; py++) { // op.Geom.FilterSz.Y {
		for (var px=0; px<op.FilterN; px++) {
			var pgi = giPool;
			if (op.InValue2 > 0) {
				var eIn = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue2), u32(yo), u32(xo), u32(py), u32(px))];
				var eGi = kp.Pool.Gi * FFFB_FFInhib(kp.Pool, eIn, eIn);
				pgi = max(pgi, eGi);
			}
			var geThr = KWTA_GeThrFromG(kp, pgi);
			var ge = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(py), u32(px))];
			var act = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(py), u32(px))];
			geAvg += ge;
			geMax = max(geMax, ge);
			var delAct = f32(0);
			var nwAct = KWTA_ActFromG(kp, geThr, ge, act, &delAct);
			Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(py), u32(px))] = nwAct;
			actAvg += nwAct;
			actMax = max(actMax, nwAct);
		}
	}
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53], u32(op.Inhibs), u32(yo), u32(xo), u32(ActAvg))] = actAvg / f32(pn);
	Inhibs[Index4D(TensorStrides[50], TensorStrides[51], TensorStrides[52], TensorStrides[53],
	u32(op.Inhibs), u32(yo), u32(xo), u32(ActMax))] = actMax;
}

//////// import: "logrenorm.go"

//////// import: "math32-fastexp.go"
fn FastExp(x: f32) -> f32 {
	if (x <= -88.02969) { // this doesn't add anything and -exp is main use-case anyway
		return f32(0.0);
	}
	var i = i32(12102203*x) + i32(127)*(i32(1)<<23);
	var m = (i >> 7) & 0xFFFF; // copy mantissa
	i += (((((((((((3537 * m) >> 16) + 13668) * m) >> 18) + 15817) * m) >> 14) - 80470) * m) >> 11);return bitcast<f32>(u32(i));
}

//////// import: "maxpool.go"

//////// import: "motion.go"

//////// import: "nxx1-nxx1.go"
struct Params {
	Thr: f32,
	Gain: f32,
	NVar: f32,
	VmActThr: f32,
	SigMult: f32,
	SigMultPow: f32,
	SigGain: f32,
	InterpRange: f32,
	GainCorRange: f32,
	GainCor: f32,
	SigGainNVar: f32,
	SigMultEff: f32,
	SigValAt0: f32,
	InterpVal: f32,
	pad: f32,
	pad1: f32,
}
fn Params_XX1(xp: Params, x: f32) -> f32 { return x / (x + 1); }
fn Params_XX1GainCor(xp: Params, x: f32) -> f32 { var gainCorFact = (xp.GainCorRange - (x / xp.NVar)) / xp.GainCorRange;; if (gainCorFact < 0) {
	return Params_XX1(xp, xp.Gain * x);
}; var newGain = xp.Gain * (1 - xp.GainCor*gainCorFact);; return Params_XX1(xp, newGain * x); }
fn Params_NoisyXX1(xp: Params, x: f32) -> f32 { if (x < 0) { // sigmoidal for < 0
	var ex = -(x * xp.SigGainNVar);
	if (ex > 50) {
		return f32(0);
	}return xp.SigMultEff / (1 + FastExp(ex));
} else if (x < xp.InterpRange) {
	var interp = 1 - ((xp.InterpRange - x) / xp.InterpRange);return xp.SigValAt0 + interp*xp.InterpVal;
} else {
	return Params_XX1GainCor(xp, x);
} }

//////// import: "op.go"
alias Operations = i32; //enums:enum
const  NoOp: Operations = 0;
const  WrapPad: Operations = 1;
const  FadePad: Operations = 2;
const  LMSImage: Operations = 3;
const  ConvolveImage: Operations = 4;
const  LogValues: Operations = 5;
const  MaxScalar: Operations = 6;
const  SumScalar: Operations = 7;
const  MeanScalar: Operations = 8;
const  NormDiv: Operations = 9;
const  NeighInhib4: Operations = 10;
const  KWTAInhib: Operations = 11;
const  MaxPool: Operations = 12;
const  MaxPolarity: Operations = 13;
const  LenSum4: Operations = 14;
const  EndStop4: Operations = 15;
const  To4D: Operations = 16;
const  MotionIntegrate: Operations = 17;
const  MotionStar: Operations = 18;
const  MotionFullField: Operations = 19;
struct Op {
	Op: Operations,
	RunN: u32,
	InImage: i32,
	InImageRGB: i32,
	InValue: i32,
	InValue2: i32,
	OutValue: i32,
	OutValue4D: i32,
	OutImage: i32,
	FilterType: i32,
	FilterN: i32,
	FloatArg1: f32,
	FloatArg2: f32,
	FloatArg3: f32,
	IntArg1: i32,
	InScalar: i32,
	OutScalar: i32,
	Inhibs: i32,
	KWTA: i32,
	pad: i32,
	Geom: Geom,
}

//////// import: "scalar.go"

//////// import: "to4d.go"