// Code generated by "gosl"; DO NOT EDIT
// kernel: Op0

// // Ops are the sequence of operations to perform, called in order. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Ops: array<Op>;
// // Filters are one general stack of rendered filters, sized to the max of each // of the inner dimensional values: [FilterTypes][FilterN][Y][X] // FilterTypes = different filter types (DoG, Gabor, etc) // FilterN = number of filters within the group (On, Off, angle, etc) // Y, X = sizes. 
@group(1) @binding(0)
var<storage, read> Filters: array<f32>;
// // Images are float-valued image data: [ImageNo][RGB][Y][X], // sized to the max of each inner-dimensional value (RGB=3, // if more needed, use additional ImageNo) 
@group(2) @binding(0)
var<storage, read_write> Images: array<f32>;
@group(2) @binding(1)
var<storage, read_write> Values: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	Op0(idx);
}

fn Index4D(s0: u32, s1: u32, s2: u32, s3: u32, i0: u32, i1: u32, i2: u32, i3: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3;
}

fn Index5D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4;
}


//////// import: "vars.go"

//////// import: "convolve.go"
fn Op_ConvolveImage(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var ii = i32(i) / op.FilterN;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var istX = op.Geom.Border.x - op.Geom.FilterLt.x;
	var istY = op.Geom.Border.y - op.Geom.FilterLt.y;
	var yi = i32(istY + yo*op.Geom.Spacing.y);
	var xi = i32(istX + xo*op.Geom.Spacing.x);
	var fyn = i32(op.Geom.FilterSz.y);
	var fxn = i32(op.Geom.FilterSz.x);
	var sum = f32(0);
	for (var fy = 0; fy < fyn; fy++) {
		for (var fx = 0; fx < fxn; fx++) {
			var iv = Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.InImage), u32(op.InImageRGB), u32(yi + fy), u32(xi + fx))];
			var fv = Filters[Index4D(TensorStrides[0], TensorStrides[1], TensorStrides[2], TensorStrides[3], u32(op.FilterType), u32(fi), u32(fy), u32(fx))];
			sum += fv * iv;
		}
	}
	sum *= op.Gain;
	if (sum > 0) {
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(0), u32(fi))] = sum;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(1), u32(fi))] = 0.0;
	} else {
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(0), u32(fi))] = 0.0;
		Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(1), u32(fi))] = -sum;
	}
}

//////// import: "enumgen.go"
const GPUVarsN: GPUVars = 5;
const OperationsN: Operations = 4;

//////// import: "geom.go"
struct Geom {
	In: vec4<i32>,
	Out: vec4<i32>,
	Border: vec4<i32>,
	Spacing: vec4<i32>,
	FilterSz: vec4<i32>,
	FilterLt: vec4<i32>,
	FilterRt: vec4<i32>,
}

//////// import: "image.go"
fn Op_WrapPad(op: Op, i: u32) {
	var ii = i32(i);
	var ri = op.InImageRGB;
	if (ri == 3) {
		var xy = op.Geom.In.x * op.Geom.In.y;
		ri = i32(i) / xy;
		ii = i32(i) % xy;
	}
	var y = ii / op.Geom.In.x;
	var x = ii % op.Geom.In.x;
	var padWidth = op.IntArg1;
	var uY = op.Geom.In.y - padWidth;
	var uX = op.Geom.In.x - padWidth;
	var sy = y;
	if (y < padWidth) {
		sy = uY - (padWidth - y);
	} else if (y >= uY) {
		sy = padWidth + (y - uY);
	}
	var sx = x;
	if (x < padWidth) {
		sx = uX - (padWidth - x);
	} else if (x >= uX) {
		sx = padWidth + (x - uX);
	}
	var iv = Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.InImage), u32(ri), u32(sy), u32(sx))];
	Images[Index4D(TensorStrides[10], TensorStrides[11], TensorStrides[12], TensorStrides[13], u32(op.OutImage), u32(ri), u32(y), u32(x))] = iv;
}

//////// import: "logrenorm.go"
fn Op_LogValues(op: Op, i: u32) {
	var fi = i32(i) % op.FilterN; // inner
	var ii = i32(i) / op.FilterN;
	var yo = ii / op.Geom.Out.x;
	var xo = ii % op.Geom.Out.x;
	var lg = log(1.0 + Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(0), u32(fi))]);
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(0), u32(fi))] = lg;
	lg = log(1.0 + Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.InValue), u32(yo), u32(xo), u32(1), u32(fi))]);
	Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(yo), u32(xo), u32(1), u32(fi))] = lg;
}

//////// import: "op.go"
alias Operations = i32; //enums:enum
const  NoOp: Operations = 0;
const  WrapPad: Operations = 1;
const  ConvolveImage: Operations = 2;
const  LogValues: Operations = 3;
struct Op {
	Op: Operations,
	RunN: u32,
	InImage: i32,
	InImageRGB: i32,
	InValue: i32,
	OutValue: i32,
	OutImage: i32,
	FilterType: i32,
	FilterN: i32,
	Gain: f32,
	IntArg1: i32,
	pad: i32,
	Geom: Geom,
}
fn Op_Run(op: Op, i: u32) {
	switch (op.Op) {
	case ConvolveImage: {
		Op_ConvolveImage(op, i);
	}
	case WrapPad: {
		Op_WrapPad(op, i);
	}
	case LogValues: {
		Op_LogValues(op, i);
	}
	default: {
	}
	}
}
fn Op0(i: u32) { //gosl:kernel
	let op = Ops[0];
	Op_Run(op, i);
}