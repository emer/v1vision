// Code generated by "gosl"; DO NOT EDIT
// kernel: SumScalarP2

// // CurOp is the current operation to perform. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> CurOp: array<Op>;
// // Filters are one general stack of rendered filters, sized to the max of each // of the inner dimensional values: [FilterTypes][FilterN][Y][X] // FilterTypes = different filter types (DoG, Gabor, etc) // FilterN = number of filters within the group (On, Off, angle, etc) // Y, X = sizes. 
// // Images are float-valued image data: [ImageNo][RGB][Y][X], // sized to the max of each inner-dimensional value (RGB=3, // if more needed, use additional ImageNo) 
@group(2) @binding(1)
var<storage, read_write> Values: array<f32>;
@group(2) @binding(3)
var<storage, read_write> Scalars: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	SumScalarP2(idx);
}

fn Index5D(s0: u32, s1: u32, s2: u32, s3: u32, s4: u32, i0: u32, i1: u32, i2: u32, i3: u32, i4: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2 + s3 * i3 + s4 * i4;
}

fn Index1D(s0: u32, i0: u32) -> u32 {
	return s0 * i0;
}


//////// import: "vars.go"

//////// import: "convolve.go"

//////// import: "enumgen.go"
const GPUVarsN: GPUVars = 6;
const OperationsN: Operations = 11;

//////// import: "geom.go"
struct Geom {
	In: vec4<i32>,
	Out: vec4<i32>,
	Border: vec4<i32>,
	Spacing: vec4<i32>,
	FilterSz: vec4<i32>,
	FilterLt: vec4<i32>,
	FilterRt: vec4<i32>,
}

//////// import: "image.go"

//////// import: "logrenorm.go"
fn SumScalarP2(i: u32) { //gosl:kernel
	if (i != 0) {
		return;
	}
	let op = CurOp[0];
	var sum = f32(0);
	for (var y=0; y<op.Geom.Out.y; y++) {
		var v = Values[Index5D(TensorStrides[20], TensorStrides[21], TensorStrides[22], TensorStrides[23], TensorStrides[24], u32(op.OutValue), u32(y), u32(0), u32(0), u32(0))];
		sum += v;
	}
	Scalars[Index1D(TensorStrides[40], u32(op.OutScalar))] = sum;
}

//////// import: "motion.go"

//////// import: "op.go"
alias Operations = i32; //enums:enum
const  NoOp: Operations = 0;
const  WrapPad: Operations = 1;
const  ConvolveImage: Operations = 2;
const  LogValues: Operations = 3;
const  MaxScalar: Operations = 4;
const  SumScalar: Operations = 5;
const  MeanScalar: Operations = 6;
const  NormDiv: Operations = 7;
const  MotionIntegrate: Operations = 8;
const  MotionStar: Operations = 9;
const  MotionFullField: Operations = 10;
struct Op {
	Op: Operations,
	RunN: u32,
	InImage: i32,
	InImageRGB: i32,
	InValue: i32,
	OutValue: i32,
	OutImage: i32,
	FilterType: i32,
	FilterN: i32,
	FloatArg1: f32,
	FloatArg2: f32,
	IntArg1: i32,
	InScalar: i32,
	OutScalar: i32,
	pad: i32,
	pad1: i32,
	Geom: Geom,
}