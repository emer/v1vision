// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package v1vision

import (
	"cogentcore.org/core/enums"
)

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6, 7}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 8

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`CurOpVar`: 0, `KWTAsVar`: 1, `FiltersVar`: 2, `ImagesVar`: 3, `ValuesVar`: 4, `Values4DVar`: 5, `ScalarsVar`: 6, `InhibsVar`: 7}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``}

var _GPUVarsMap = map[GPUVars]string{0: `CurOpVar`, 1: `KWTAsVar`, 2: `FiltersVar`, 3: `ImagesVar`, 4: `ValuesVar`, 5: `Values4DVar`, 6: `ScalarsVar`, 7: `InhibsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _InhibVarsValues = []InhibVars{0, 1, 2, 3, 4, 5, 6, 7, 8}

// InhibVarsN is the highest valid value for type InhibVars, plus one.
//
//gosl:start
const InhibVarsN InhibVars = 9

//gosl:end

var _InhibVarsValueMap = map[string]InhibVars{`FFi`: 0, `FBi`: 1, `Gi`: 2, `GiOrig`: 3, `LayGi`: 4, `GeAvg`: 5, `GeMax`: 6, `ActAvg`: 7, `ActMax`: 8}

var _InhibVarsDescMap = map[InhibVars]string{0: `computed feedforward inhibition`, 1: `computed feedback inhibition (total)`, 2: `overall value of the inhibition. This is what is added into the unit Gi inhibition level (along with any synaptic unit-driven inhibition)`, 3: `original value of the inhibition (before pool or other effects)`, 4: `for pools, this is the layer-level inhibition that is MAX&#39;d with the pool-level inhibition to produce the net inhibition.`, 5: `average Ge excitatory conductance values, which drive FF inhibition`, 6: `max Ge excitatory conductance values, which drive FF inhibition`, 7: `average Act activation values, which drive FB inhibition`, 8: `max Act activation values, which drive FB inhibition`}

var _InhibVarsMap = map[InhibVars]string{0: `FFi`, 1: `FBi`, 2: `Gi`, 3: `GiOrig`, 4: `LayGi`, 5: `GeAvg`, 6: `GeMax`, 7: `ActAvg`, 8: `ActMax`}

// String returns the string representation of this InhibVars value.
func (i InhibVars) String() string { return enums.String(i, _InhibVarsMap) }

// SetString sets the InhibVars value from its string representation,
// and returns an error if the string is invalid.
func (i *InhibVars) SetString(s string) error {
	return enums.SetString(i, s, _InhibVarsValueMap, "InhibVars")
}

// Int64 returns the InhibVars value as an int64.
func (i InhibVars) Int64() int64 { return int64(i) }

// SetInt64 sets the InhibVars value from an int64.
func (i *InhibVars) SetInt64(in int64) { *i = InhibVars(in) }

// Desc returns the description of the InhibVars value.
func (i InhibVars) Desc() string { return enums.Desc(i, _InhibVarsDescMap) }

// InhibVarsValues returns all possible values for the type InhibVars.
func InhibVarsValues() []InhibVars { return _InhibVarsValues }

// Values returns all possible values for the type InhibVars.
func (i InhibVars) Values() []enums.Enum { return enums.Values(_InhibVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i InhibVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *InhibVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "InhibVars")
}

var _OperationsValues = []Operations{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}

// OperationsN is the highest valid value for type Operations, plus one.
//
//gosl:start
const OperationsN Operations = 24

//gosl:end

var _OperationsValueMap = map[string]Operations{`NoOp`: 0, `WrapPad`: 1, `EdgeAvg`: 2, `FadePad`: 3, `LMSOpponents`: 4, `LMSComponents`: 5, `ConvolveImage`: 6, `ConvolveDiff`: 7, `LogValues`: 8, `MaxScalar`: 9, `SumScalar`: 10, `MeanScalar`: 11, `NormDiv`: 12, `NeighInhib4`: 13, `KWTAInhib`: 14, `MaxPool`: 15, `MaxPolarity`: 16, `MaxCopy`: 17, `LenSum4`: 18, `EndStop4`: 19, `To4D`: 20, `MotionIntegrate`: 21, `MotionStar`: 22, `MotionFullField`: 23}

var _OperationsDescMap = map[Operations]string{0: ``, 1: `WrapPad wraps given padding width of float32 image around sides i.e., padding for left side of image is the (mirrored) bits from the right side of image, etc. InImage -&gt; OutImage, over InImageRGB (if 3, does all).`, 2: `EdgeAvg computes the average r,g,b values around the edges of an image, storing into Scalars. These are then used for FadePad.`, 3: `FadePad wraps given padding width of float32 image around sides i.e., padding for left side of image is the (mirrored) bits from the right side of image, etc, and fades result toward average edge value (passed in as arg). InImage -&gt; OutImage, over InImageRGB (if 3, does all).`, 4: `LMSOpponents computes Long-Medium-Short (RGB) perceptually-based color opponent values from InImage -&gt; OutImage. 0 = RedGreen (L-M), 1 = White-Black (grey), 2 = BlueYellow (S-(LM)),`, 5: `LMSComponents computes Long-Medium-Short (RGB) perceptually-based color component values from InImage -&gt; OutImage1, OutImage2. For each image, the organization of components is designed to align with the RGB components, using grey to fill in the extra bit. Image1: 0 = Red (L), 1 = Green (M), 2 = Grey Image2: 0 = Yellow (LM), 1 = Grey, 2 = Blue (S),`, 6: `ConvolveImage applies a filter to Image, writing to Values. InImage -&gt; OutValue, using FilterType, FilterN`, 7: `ConvolveDiff applies two different filters to two different [Image, component] inputs, computing their difference, with positive values in 0 and negative values in 1 polarity, at given feature dimension (innermost Values dimension). This is used to compute e.g., on-center DoG to one color component minus off-center to another component.`, 8: `LogValues sets values to 1 + log of values * Gain. InValue -&gt; OutValue (can be the same).`, 9: `MaxScalar computes Max over values. InValue = values, OutScalar = result.`, 10: `SumScalar computes Sum over values InValue = values, OutScalar = result.`, 11: `MeanScalar computes Mean over values InValue = values, OutScalar = result.`, 12: `NormDiv normalizes values by scalar InValue -&gt; OutValue (can be same), InScalar = norm factor.`, 13: `NeighInhib4 computes neighbor inhibition, as an optional preliminary step prior to KWTA. Currently only works with 4 angles (n features=4). Each unit gets inhibition from same feature in nearest orthogonal neighbors. Reduces redundancy of feature code.`, 14: `KWTAInhib computes k-winners-take-all inhibition, rate-code version, based on overall levels of activity, over multiple iterations.`, 15: `MaxPool performs max-pooling over given pool size and spacing, effectively reducing the dimensionality of the output by the spacing factor. Size must = spacing or 2 * spacing.`, 16: `MaxPolarity performs max-pooling over the polarity (on vs. off) dimension.`, 17: `MaxCopy performs simple max over 2 different values, for aggregating different channels (e.g., colors) into a summary, without changing the dimensionality.`, 18: `LenSum4 performs V1 complex-cell length-summing, extending the receptive field along the orientation angle one step. Works on output from [MaxPolarity] (first polarity dimension), only for the 4 angles case.`, 19: `EndStop4 performs V1 complex-cell end-stop, detecting an orthoginal angle at the end of a length-sum line. Only for the 4 angles case.`, 20: `To4D copies from Values to Values4D for aggregating final results across multiple feature dimensions (e.g., for assembling full V1 complex).`, 21: `MotionIntegrate does fast and slow motion integration from values to values: InValue -&gt; OutValue (should be different)`, 22: `MotionStar computes starburst-style motion on integrated fast and slow input values. Result is 4 * FilterN filter outputs, for Left, Right, Down, Up motion directions. InValue -&gt; OutValue (different, X and Y are -1 in output).`, 23: `MotionFullField computes full-field summary of output from MotionStar, into 4 Scalars for Left, Right, Down, Up. Opposite directions compete. OutScalar[0-3] = instantaneous full-field values per this frame OutScalar[4-7] = integrated full-field values over time`}

var _OperationsMap = map[Operations]string{0: `NoOp`, 1: `WrapPad`, 2: `EdgeAvg`, 3: `FadePad`, 4: `LMSOpponents`, 5: `LMSComponents`, 6: `ConvolveImage`, 7: `ConvolveDiff`, 8: `LogValues`, 9: `MaxScalar`, 10: `SumScalar`, 11: `MeanScalar`, 12: `NormDiv`, 13: `NeighInhib4`, 14: `KWTAInhib`, 15: `MaxPool`, 16: `MaxPolarity`, 17: `MaxCopy`, 18: `LenSum4`, 19: `EndStop4`, 20: `To4D`, 21: `MotionIntegrate`, 22: `MotionStar`, 23: `MotionFullField`}

// String returns the string representation of this Operations value.
func (i Operations) String() string { return enums.String(i, _OperationsMap) }

// SetString sets the Operations value from its string representation,
// and returns an error if the string is invalid.
func (i *Operations) SetString(s string) error {
	return enums.SetString(i, s, _OperationsValueMap, "Operations")
}

// Int64 returns the Operations value as an int64.
func (i Operations) Int64() int64 { return int64(i) }

// SetInt64 sets the Operations value from an int64.
func (i *Operations) SetInt64(in int64) { *i = Operations(in) }

// Desc returns the description of the Operations value.
func (i Operations) Desc() string { return enums.Desc(i, _OperationsDescMap) }

// OperationsValues returns all possible values for the type Operations.
func OperationsValues() []Operations { return _OperationsValues }

// Values returns all possible values for the type Operations.
func (i Operations) Values() []enums.Enum { return enums.Values(_OperationsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Operations) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Operations) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "Operations")
}
